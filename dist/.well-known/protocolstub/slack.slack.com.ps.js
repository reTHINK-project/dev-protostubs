System.register([], function(__WEBPACK_DYNAMIC_EXPORT__) {

	return {

		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/protostub/slack/slack.slack.com.ps.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/protostub/slack/node_modules/slack/index.js":
/*!*********************************************************!*\
  !*** ./src/protostub/slack/node_modules/slack/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("let bind = __webpack_require__(/*! ./src/_bind */ \"./src/protostub/slack/node_modules/slack/src/_bind.js\")\nlet exec = __webpack_require__(/*! ./src/_exec */ \"./src/protostub/slack/node_modules/slack/src/_exec-browser.js\")\nlet factory = __webpack_require__(/*! ./src/_factory */ \"./src/protostub/slack/node_modules/slack/src/_factory.js\")\n\n/**\n * bind accepts an object, in this case the factory function, and\n * applies exec to the Slack API methods as defined in api.json\n */\nmodule.exports = bind(factory, exec)\n\n\n//# sourceURL=webpack:///./src/protostub/slack/node_modules/slack/index.js?");

/***/ }),

/***/ "./src/protostub/slack/node_modules/slack/src/_bind.js":
/*!*************************************************************!*\
  !*** ./src/protostub/slack/node_modules/slack/src/_bind.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ./api.json */ \"./src/protostub/slack/node_modules/slack/src/api.json\")\n\n/**\n * reads api.json and generates a matching javascript object\n * the leaf nodes bind the method name to the passed in exec function\n */\nmodule.exports = function _bind(ns, exec) {\n\n  // walks the generated api.json keys dynamically constructing the client\n  Object.keys(api).forEach(key=> {\n\n    // each key is namespaced so we break up into an array to work with \n    // example: api.test --> ['api', 'test']\n    var parts = key.split('.')\n\n    // then we get the root part of the namespace\n    // example: 'api'\n    var root = parts.shift() \n  \n    // initialize the root namespace object if it wasn't already\n    var init = typeof ns[root] === 'undefined'\n    if (init) {\n      ns[root] = {} \n    }\n\n    // walks the remaining namespace parts assigning the _exec function at the end\n    ;(function _iterator(o) {\n      var bit = parts.shift()\n      var last = parts.length === 0\n      if (last) {\n        o[bit] = exec.bind({}, key)\n      }\n      else {\n        var init = typeof o[bit] === 'undefined'\n        if (init) {\n          o[bit] = {}\n        }\n        // keep iterating\n        _iterator(o[bit])\n      }\n    })(ns[root])\n  })\n\n  return ns\n}\n\n\n//# sourceURL=webpack:///./src/protostub/slack/node_modules/slack/src/_bind.js?");

/***/ }),

/***/ "./src/protostub/slack/node_modules/slack/src/_exec-browser.js":
/*!*********************************************************************!*\
  !*** ./src/protostub/slack/node_modules/slack/src/_exec-browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("let validate = __webpack_require__(/*! ./_validate */ \"./src/protostub/slack/node_modules/slack/src/_validate.js\")\nlet encode = encodeURIComponent\nlet serialize = o=> Object.keys(o).map(k=> encode(k) + '=' + encode(o[k])).join('&')\n\n/**\n * returns a promise if callback isn't defined; _exec is the actual impl\n */\nmodule.exports = function exec(url, params, callback) {\n  if (!callback) {\n    return new Promise(function(resolve, reject) {\n      _exec(url, params, function __exec(err, res) {\n        if (err) {\n          reject(err)\n        }\n        else { \n          resolve(res)\n        }\n      })\n    })\n  }\n  else {\n    _exec(url, params, callback)\n  }\n}\n\nasync function _exec(url, params, callback) {\n  try {\n    // validates the params against api.json\n    var err = validate(url, params)\n    if (err) throw err\n\n    // stringify any objects under keys since form \n    // is posted as application/x-www-form-urlencoded\n    Object.keys(params).forEach(function (key) {\n      if (typeof params[key] === 'object') {\n        params[key] = JSON.stringify(params[key])\n      }\n    })\n\n    var opts = {\n      method: 'POST', \n      headers: new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }),\n      body: serialize(params)\n    }\n\n    var res = await fetch(`https://slack.com/api/${url}`, opts)\n    var json = await res.json()\n\n    if (json.error) {\n      callback(Error(json.error))\n    }\n    else {\n      callback(null, json)\n    }\n  }\n  catch(e) {\n    callback(e)\n  }\n}\n\n\n//# sourceURL=webpack:///./src/protostub/slack/node_modules/slack/src/_exec-browser.js?");

/***/ }),

/***/ "./src/protostub/slack/node_modules/slack/src/_factory.js":
/*!****************************************************************!*\
  !*** ./src/protostub/slack/node_modules/slack/src/_factory.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var bind = __webpack_require__(/*! ./_bind */ \"./src/protostub/slack/node_modules/slack/src/_bind.js\")\nvar exec = __webpack_require__(/*! ./_exec */ \"./src/protostub/slack/node_modules/slack/src/_exec-browser.js\")\n\n/** \n * factory returns a new instance of Slack\n * \n * things to understand:\n *\n * - this function is the root object exported \n * - can be a constuctor for creating oo style instances of Slack \n * - requires named params to allow for future flexability in the function sig\n * - all methods have token pre applied\n * - all methods either accept a callback or return a promise\n */\nmodule.exports = function factory(xxx) {\n  \n  if (!xxx) xxx = {}\n\n  // Slack instance applies the token param to all the api methods\n  class Slack {\n    constructor() {\n      function _execWithToken(method, params, callback) {\n        params.token = params.token || xxx.token\n        return exec(method, params, callback)\n      }\n      // bind applies the above method to this obj\n      // bind also returns all methods promisified\n      bind(this, _execWithToken)\n    }\n  }\n\n  return new Slack\n}\n\n\n//# sourceURL=webpack:///./src/protostub/slack/node_modules/slack/src/_factory.js?");

/***/ }),

/***/ "./src/protostub/slack/node_modules/slack/src/_validate.js":
/*!*****************************************************************!*\
  !*** ./src/protostub/slack/node_modules/slack/src/_validate.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ./api.json */ \"./src/protostub/slack/node_modules/slack/src/api.json\")\n\nmodule.exports = function validate(method, params) {\n  // get all the requried params for this method\n  let required = api[method]\n  // collect any missing params\n  let missing = required.filter(param=> typeof params[param] === 'undefined')\n  // optimistic: assume the best but have a plan for the worst\n  return missing.length? Error(`${method} missing params: ${missing.join(', ')}`) : false\n}\n\n\n//# sourceURL=webpack:///./src/protostub/slack/node_modules/slack/src/_validate.js?");

/***/ }),

/***/ "./src/protostub/slack/node_modules/slack/src/api.json":
/*!*************************************************************!*\
  !*** ./src/protostub/slack/node_modules/slack/src/api.json ***!
  \*************************************************************/
/*! exports provided: api.test, apps.permissions.info, apps.permissions.request, auth.revoke, auth.test, bots.info, channels.archive, channels.create, channels.history, channels.info, channels.invite, channels.join, channels.kick, channels.leave, channels.list, channels.mark, channels.rename, channels.replies, channels.setPurpose, channels.setTopic, channels.unarchive, chat.delete, chat.meMessage, chat.postEphemeral, chat.postMessage, chat.unfurl, chat.update, conversations.archive, conversations.close, conversations.create, conversations.history, conversations.info, conversations.invite, conversations.join, conversations.kick, conversations.leave, conversations.list, conversations.members, conversations.open, conversations.rename, conversations.replies, conversations.setPurpose, conversations.setTopic, conversations.unarchive, dnd.endDnd, dnd.endSnooze, dnd.info, dnd.setSnooze, dnd.teamInfo, emoji.list, files.comments.add, files.comments.delete, files.comments.edit, files.delete, files.info, files.list, files.revokePublicURL, files.sharedPublicURL, files.upload, groups.archive, groups.create, groups.createChild, groups.history, groups.info, groups.invite, groups.kick, groups.leave, groups.list, groups.mark, groups.open, groups.rename, groups.replies, groups.setPurpose, groups.setTopic, groups.unarchive, im.close, im.history, im.list, im.mark, im.open, im.replies, mpim.close, mpim.history, mpim.list, mpim.mark, mpim.open, mpim.replies, oauth.access, oauth.token, pins.add, pins.list, pins.remove, reactions.add, reactions.get, reactions.list, reactions.remove, reminders.add, reminders.complete, reminders.delete, reminders.info, reminders.list, rtm.connect, rtm.start, search.all, search.files, search.messages, stars.add, stars.list, stars.remove, team.accessLogs, team.billableInfo, team.info, team.integrationLogs, team.profile.get, usergroups.create, usergroups.disable, usergroups.enable, usergroups.list, usergroups.update, usergroups.users.list, usergroups.users.update, users.deletePhoto, users.getPresence, users.identity, users.info, users.list, users.setActive, users.setPhoto, users.setPresence, users.profile.get, users.profile.set, default */
/***/ (function(module) {

eval("module.exports = {\"api.test\":[],\"apps.permissions.info\":[\"token\"],\"apps.permissions.request\":[\"token\",\"scopes\",\"trigger_id\"],\"auth.revoke\":[\"token\"],\"auth.test\":[\"token\"],\"bots.info\":[\"token\"],\"channels.archive\":[\"token\",\"channel\"],\"channels.create\":[\"token\",\"name\"],\"channels.history\":[\"token\",\"channel\"],\"channels.info\":[\"token\",\"channel\"],\"channels.invite\":[\"token\",\"channel\",\"user\"],\"channels.join\":[\"token\",\"name\"],\"channels.kick\":[\"token\",\"channel\",\"user\"],\"channels.leave\":[\"token\",\"channel\"],\"channels.list\":[\"token\"],\"channels.mark\":[\"token\",\"channel\",\"ts\"],\"channels.rename\":[\"token\",\"channel\",\"name\"],\"channels.replies\":[\"token\",\"channel\",\"thread_ts\"],\"channels.setPurpose\":[\"token\",\"channel\",\"purpose\"],\"channels.setTopic\":[\"token\",\"channel\",\"topic\"],\"channels.unarchive\":[\"token\",\"channel\"],\"chat.delete\":[\"token\",\"channel\",\"ts\"],\"chat.meMessage\":[\"token\",\"channel\",\"text\"],\"chat.postEphemeral\":[\"token\",\"channel\",\"text\",\"user\"],\"chat.postMessage\":[\"token\",\"channel\",\"text\"],\"chat.unfurl\":[\"token\",\"channel\",\"ts\",\"unfurls\"],\"chat.update\":[\"token\",\"channel\",\"text\",\"ts\"],\"conversations.archive\":[\"token\",\"channel\"],\"conversations.close\":[\"token\",\"channel\"],\"conversations.create\":[\"token\",\"name\"],\"conversations.history\":[\"token\",\"channel\"],\"conversations.info\":[\"token\",\"channel\"],\"conversations.invite\":[\"token\",\"channel\",\"users\"],\"conversations.join\":[\"token\",\"channel\"],\"conversations.kick\":[\"token\",\"channel\",\"user\"],\"conversations.leave\":[\"token\",\"channel\"],\"conversations.list\":[\"token\"],\"conversations.members\":[\"token\",\"channel\"],\"conversations.open\":[\"token\"],\"conversations.rename\":[\"token\",\"channel\",\"name\"],\"conversations.replies\":[\"token\",\"channel\",\"ts\"],\"conversations.setPurpose\":[\"token\",\"channel\",\"purpose\"],\"conversations.setTopic\":[\"token\",\"channel\",\"topic\"],\"conversations.unarchive\":[\"token\",\"channel\"],\"dnd.endDnd\":[\"token\"],\"dnd.endSnooze\":[\"token\"],\"dnd.info\":[\"token\"],\"dnd.setSnooze\":[\"token\",\"num_minutes\"],\"dnd.teamInfo\":[\"token\"],\"emoji.list\":[\"token\"],\"files.comments.add\":[\"token\",\"comment\",\"file\"],\"files.comments.delete\":[\"token\",\"file\",\"id\"],\"files.comments.edit\":[\"token\",\"comment\",\"file\",\"id\"],\"files.delete\":[\"token\",\"file\"],\"files.info\":[\"token\",\"file\"],\"files.list\":[\"token\"],\"files.revokePublicURL\":[\"token\",\"file\"],\"files.sharedPublicURL\":[\"token\",\"file\"],\"files.upload\":[\"token\"],\"groups.archive\":[\"token\",\"channel\"],\"groups.create\":[\"token\",\"name\"],\"groups.createChild\":[\"token\",\"channel\"],\"groups.history\":[\"token\",\"channel\"],\"groups.info\":[\"token\",\"channel\"],\"groups.invite\":[\"token\",\"channel\",\"user\"],\"groups.kick\":[\"token\",\"channel\",\"user\"],\"groups.leave\":[\"token\",\"channel\"],\"groups.list\":[\"token\"],\"groups.mark\":[\"token\",\"channel\",\"ts\"],\"groups.open\":[\"token\",\"channel\"],\"groups.rename\":[\"token\",\"channel\",\"name\"],\"groups.replies\":[\"token\",\"channel\",\"thread_ts\"],\"groups.setPurpose\":[\"token\",\"channel\",\"purpose\"],\"groups.setTopic\":[\"token\",\"channel\",\"topic\"],\"groups.unarchive\":[\"token\",\"channel\"],\"im.close\":[\"token\",\"channel\"],\"im.history\":[\"token\",\"channel\"],\"im.list\":[\"token\"],\"im.mark\":[\"token\",\"channel\",\"ts\"],\"im.open\":[\"token\",\"user\"],\"im.replies\":[\"token\",\"channel\",\"thread_ts\"],\"mpim.close\":[\"token\",\"channel\"],\"mpim.history\":[\"token\",\"channel\"],\"mpim.list\":[\"token\"],\"mpim.mark\":[\"token\",\"channel\",\"ts\"],\"mpim.open\":[\"token\",\"users\"],\"mpim.replies\":[\"token\",\"channel\",\"thread_ts\"],\"oauth.access\":[\"client_id\",\"client_secret\",\"code\"],\"oauth.token\":[\"client_id\",\"client_secret\",\"code\"],\"pins.add\":[\"token\",\"channel\"],\"pins.list\":[\"token\",\"channel\"],\"pins.remove\":[\"token\",\"channel\"],\"reactions.add\":[\"token\",\"name\"],\"reactions.get\":[\"token\"],\"reactions.list\":[\"token\"],\"reactions.remove\":[\"token\",\"name\"],\"reminders.add\":[\"token\",\"text\",\"time\"],\"reminders.complete\":[\"token\",\"reminder\"],\"reminders.delete\":[\"token\",\"reminder\"],\"reminders.info\":[\"token\",\"reminder\"],\"reminders.list\":[\"token\"],\"rtm.connect\":[\"token\"],\"rtm.start\":[\"token\"],\"search.all\":[\"token\",\"query\"],\"search.files\":[\"token\",\"query\"],\"search.messages\":[\"token\",\"query\"],\"stars.add\":[\"token\"],\"stars.list\":[\"token\"],\"stars.remove\":[\"token\"],\"team.accessLogs\":[\"token\"],\"team.billableInfo\":[\"token\"],\"team.info\":[\"token\"],\"team.integrationLogs\":[\"token\"],\"team.profile.get\":[\"token\"],\"usergroups.create\":[\"token\",\"name\"],\"usergroups.disable\":[\"token\",\"usergroup\"],\"usergroups.enable\":[\"token\",\"usergroup\"],\"usergroups.list\":[\"token\"],\"usergroups.update\":[\"token\",\"usergroup\"],\"usergroups.users.list\":[\"token\",\"usergroup\"],\"usergroups.users.update\":[\"token\",\"usergroup\",\"users\"],\"users.deletePhoto\":[\"token\"],\"users.getPresence\":[\"token\",\"user\"],\"users.identity\":[\"token\"],\"users.info\":[\"token\",\"user\"],\"users.list\":[\"token\"],\"users.setActive\":[\"token\"],\"users.setPhoto\":[\"token\",\"image\"],\"users.setPresence\":[\"token\",\"presence\"],\"users.profile.get\":[\"token\"],\"users.profile.set\":[\"token\"]};\n\n//# sourceURL=webpack:///./src/protostub/slack/node_modules/slack/src/api.json?");

/***/ }),

/***/ "./src/protostub/slack/slack.slack.com.ps.js":
/*!***************************************************!*\
  !*** ./src/protostub/slack/slack.slack.com.ps.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SlackProtoStub; });\n/* harmony import */ var slack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! slack */ \"./src/protostub/slack/node_modules/slack/index.js\");\n/* harmony import */ var slack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(slack__WEBPACK_IMPORTED_MODULE_0__);\n\r\n//import { Syncher, NotificationHandler } from 'service-framework/dist/Syncher';\r\n//import IdentityManager from 'service-framework/dist/IdentityManager';\r\n//import {ChatManager} from 'runtime-core/dist/ChatManager';\r\n//import MessageBodyIdentity from 'service-framework/dist/IdentityFactory';\r\n//import {ContextReporter} from 'service-framework/dist/ContextManager';\r\n\r\n\r\nclass SlackProtoStub {\r\n\r\n  constructor() {\r\n\r\n  }\r\n  _start(runtimeProtoStubURL, bus, config, factory) {\r\n\r\n    if (!runtimeProtoStubURL) throw new Error('The runtimeProtoStubURL is a needed parameter');\r\n    if (!bus) throw new Error('The bus is a needed parameter');\r\n    if (!config) throw new Error('The config is a needed parameter');\r\n\r\n    console.log('[SlackProtostub] Constructor Loaded');\r\n\r\n    let _this = this;\r\n    this._ws = null;\r\n    this._toSubscribePresence = [];\r\n    this._addedUsersInfo = [];\r\n    this._alreadyCreated = false;\r\n    this._slack = slack__WEBPACK_IMPORTED_MODULE_0___default.a;\r\n    this._usersUpdated = false;\r\n    this._subscribedList = [];\r\n    this._messageHistoryControl = {};\r\n    this._usersList = [];\r\n    //this._groupsList = [];\r\n    this._channelsList = [];\r\n    //this._imsList = [];\r\n    //this._observer;\r\n    this._id = 0;\r\n    //this._continuousOpen = true;\r\n    this._token = '';\r\n    //this._chatController;\r\n    //this._chatControllersExtra = {};\r\n    //this._schemaURL;\r\n    this._dataObjectReporterURL;\r\n    this._factory = factory;\r\n    this._contextReportersInfo = {};\r\n    this._syncher = factory.createSyncher(runtimeProtoStubURL, bus, config);\r\n    this._chatManager = factory.createChatManager(runtimeProtoStubURL, bus, config, this._syncher);\r\n    this._contextReporter = factory.createContextReporter(runtimeProtoStubURL, bus, config, this._syncher);\r\n\r\n    this._myUrl = runtimeProtoStubURL;\r\n    this._bus = bus;\r\n    this._config = config;\r\n\r\n    this._runtimeSessionURL = config.runtimeURL;\r\n    this._reOpen = false;\r\n    this._chatManager.onInvitation((event) => {\r\n      _this._onSlackInvitation(event);\r\n    });\r\n\r\n    this._notificationHandler = factory.createNotificationHandler(bus);\r\n\r\n    this._notificationHandler.onNotification('comm', (event) => {\r\n      _this._chatManager.processNotification(event);\r\n    });\r\n\r\n    bus.addListener('*', (msg) => {\r\n      //ignore msg sent by himself\r\n      if (msg.from !== runtimeProtoStubURL) {\r\n        console.log('[SlackProtostub] new msg ', msg);\r\n        switch (msg.type) {\r\n          case 'create': _this._notificationHandler.onCreate(msg); break;\r\n          case 'delete': _this._notificationHandler.onDelete(msg); break;\r\n        }\r\n      }\r\n    });\r\n\r\n    _this._sendStatus('created');\r\n\r\n  }\r\n\r\n\r\n  get config() { return this._config; }\r\n\r\n  get runtimeSession() { return this._runtimeSessionURL; }\r\n\r\n  _filter(msg) {\r\n    if (msg.via === this._myUrl) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It Open a new Session using received token connect to a webSocket Url,\r\n  *  where handle all received messages on this socket\r\n  * @param {string} token - message with a new user added\r\n  *******************************************************************************************************/\r\n  _open(token, callback) {\r\n    let _this = this;\r\n\r\n    if (!_this._session) {\r\n      console.log('[SlackProtostub] creating Session for token:', token);\r\n      _this._sendStatus('in-progress');\r\n\r\n      _this._session = this._slack.rtm.connect({token: token, batch_presence_aware: 1, presence_sub: true});\r\n      console.log('[SlackProtostub] session', _this._session);\r\n      _this._session.createdTime = new Date().getTime() / 1000;\r\n\r\n      _this._session.then(function(result) {\r\n        console.log('[SlackProtostub] Session result', result);\r\n        if (result.ok) {\r\n          _this._ws = new WebSocket(result.url);\r\n          console.log('[SlackProtostub] websocket', _this._ws);\r\n          console.log('[SlackProtostub] websocket url ', _this._ws.url);\r\n\r\n\r\n          _this._ws.onmessage = function (event) {\r\n            let msg = JSON.parse(event.data);\r\n            console.log('[SlackProtostub] new msg on webSocket', msg);\r\n\r\n            if (msg.type == 'message') {\r\n              _this._handleNewMessage(msg);\r\n            } else if (msg.type == 'presence_change') {\r\n              _this._handlePresenceChange(msg);\r\n            } else if (msg.type == 'member_joined_channel') {\r\n              _this._handleNewUser(msg);\r\n            }\r\n          };\r\n          _this._ws.onerror = function(error){\r\n            console.log('[SlackProtostub] websocker Error', error);\r\n          }\r\n        }\r\n      });\r\n      _this._sendStatus('live');\r\n    } else {\r\n\r\n      console.log('[SlackProtostub] session already exist');\r\n    }\r\n    setTimeout(() => {callback();});\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It Resumes all reporters including contextreporters\r\n  * @param {string} reporterURL - message with a new user added\r\n  * @return {Promise<Object>} Returns a promise with a reporter DataObject\r\n  *******************************************************************************************************/\r\n  _resumeReporter(reporterURL) {\r\n    let _this = this;\r\n    return new Promise(function(resolve,reject) {\r\n      console.log('[SlackProtostub] resuming reporter of ', reporterURL);\r\n      _this._syncher.resumeReporters({store: true, reporter: reporterURL}).then((reporters) => {\r\n        let dataObjectReporter;\r\n        let reportersList = Object.keys(reporters);\r\n\r\n        console.log('[SlackProtostub] ', reporters, reportersList);\r\n        let i = 0;\r\n        reportersList.forEach(function(key) {\r\n          if(reporters[key]._name === reporterURL && key.startsWith('context://')) {\r\n            console.log('[SlackProtostub] reporter to return', reporters[key]);\r\n            return resolve(reporters[key]);\r\n          }\r\n        });\r\n        return resolve(false);\r\n      });\r\n    })\r\n\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It is called when a event ocurred related with a invitation of a slack User\r\n  * @param {Object} event - Object event\r\n  *******************************************************************************************************/\r\n  _onSlackInvitation(event) {\r\n    let _this = this;\r\n\r\n    if (event.identity.hasOwnProperty('accessToken') && event.identity.accessToken) {\r\n\r\n      this._token = event.identity.accessToken;\r\n\r\n      _this._open(this._token, ()=> {\r\n        if (_this._filter(event)) {\r\n\r\n          console.log('[SlackProtostub] After Filter', event);\r\n\r\n          let schemaUrl = event.schema;\r\n          if (event.value.name) {\r\n\r\n            let schemaSplitted =  schemaUrl.split('/');\r\n\r\n            if (schemaSplitted[schemaSplitted.length - 1] === 'Communication') {\r\n\r\n              _this._getSlackInformation(event.to, event.identity.input.user_id).then((infoReturned) => {\r\n\r\n                let userInfo = infoReturned.ownInfo;\r\n                let toInvInfo = infoReturned.invInfo;\r\n                console.log('Slack User information: ', infoReturned, event);\r\n\r\n                // username, userURL, avatar, cn, locale, idp, assertion\r\n                let identity = _this._factory.createMessageBodyIdentity(\r\n                  userInfo.name,\r\n                  'slack://slack.com/' + userInfo.name + '@slack.com',\r\n                  userInfo.profile.image_192,\r\n                  userInfo.name,\r\n                  '', 'slack.com', undefined, userInfo.profile);\r\n\r\n                let identityToInv = _this._factory.createMessageBodyIdentity(\r\n                  toInvInfo.name,\r\n                  'slack://slack.com/' + toInvInfo.name + '@slack.com',\r\n                  toInvInfo.profile.image_192,\r\n                  toInvInfo.name,\r\n                  '', 'slack.com', undefined, toInvInfo.profile);\r\n\r\n                  event.ack(200);\r\n\r\n\r\n                  console.log('[SlackProtostub] subscribing object', event.url, identity);\r\n\r\n                  let neededInfoInvited = { id: toInvInfo.id, name: toInvInfo.name, userURL: identityToInv.userProfile.userURL, identity: identityToInv}\r\n                  let neededOwnInfo = { id: event.identity.input.user_id, userURL: identity.userProfile.userURL}\r\n\r\n                  if (! _this._alreadyCreated) {\r\n                    console.log('[SlackProtostub] Not Already created', event);\r\n                    _this._alreadyCreated = true;\r\n                    //_this._schemaURL = event.schema;\r\n                    _this._dataObjectReporterURL = event.url;\r\n\r\n                    let userToAdd = { user : 'slack://'+userInfo.name+'@slack.com', domain: 'slack.com', id: event.identity.input.user_id, userURL: 'slack://slack.com/'+userInfo.name+'@slack.com', identity: identity};\r\n                    _this._addedUsersInfo.push(userToAdd);\r\n\r\n                    _this._createNewContextReporter(identity.userProfile.userURL).then(function(creation) {\r\n                      //debugger;\r\n                      if (creation == true) {\r\n                        _this._chatManager.join(event.url, false, identity).then((chatController) => {\r\n                          _this._prepareChat(chatController);\r\n                          let msgQuery = { \"type\": \"presence_sub\",\r\n                                         \"ids\": _this._toSubscribePresence };\r\n                          console.log('[SlackProtostub] websocket sentmessage', _this._ws.readyState, msgQuery);\r\n                          _this._ws.send(JSON.stringify(msgQuery));\r\n                          //_this._createNewContextReporter(identity.userProfile.userURL);\r\n\r\n                          let subscription = {\r\n                            urlDataObj: event.url,\r\n                            schema: event.schema,\r\n                            subscribed: true,\r\n                            identity: identity,\r\n                            chat: chatController\r\n                          };\r\n\r\n                          _this._subscribedList.push(subscription);\r\n                          console.log('[SlackProtostub] subscribed list', _this._subscribedList);\r\n                          if (event.identity.input.user_id) {\r\n                            _this._id = event.identity.input.user_id\r\n                          }\r\n\r\n                          //_this._channelStatusInfo(event, toInvInfo.id, event.url, toInvInfo.name, identityToInv.userProfile.userURL, event.url, identityToInv, identity.userProfile.userURL, event.identity.input.user_id);\r\n                          _this._channelStatusInfo(event, neededInfoInvited, neededOwnInfo);\r\n\r\n                        });\r\n                      }\r\n                    });\r\n\r\n                  } else {\r\n                    console.log('[SlackProtostub] Already created', event);\r\n                    console.log(_this._subscribedList.length);\r\n                    if ( _this._subscribedList.length != 0 ) {\r\n                      _this._channelStatusInfo(event, neededInfoInvited, neededOwnInfo);\r\n                    } else {\r\n                      let testURL = event.to.split('//')[0] + '//slack.com/' + event.to.split('//')[1]\r\n                      _this._createNewContextReporter(testURL);\r\n                    }\r\n                  }\r\n\r\n              });\r\n            } else event.error('Invalid Scheme: ' + schemaSplitted[schemaSplitted.length - 1]);\r\n          } else event.error('Chat Name Missing');\r\n        }\r\n      });\r\n    } else event.error('Access Token Missing');\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It creates a new contextReporter with userURL\r\n  * @param {string} userURL - userURL of user to create a new ContextReporter\r\n  *******************************************************************************************************/\r\n  _createNewContextReporter(userURL) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      _this._resumeReporter(userURL).then(function(reporterResumed) {\r\n\r\n        console.log('[SlackProtostub] TEST creating reporter for', userURL);\r\n        _this._addedUsersInfo.forEach(function(currentUser) {\r\n\r\n          if(currentUser.userURL == userURL ) {\r\n            console.log('[SlackProtostub] TEST get presense for ', currentUser);\r\n            let toGetPresence = { token: _this._token, user: currentUser.id };\r\n\r\n            _this._slack.users.getPresence(toGetPresence, (err, data) => {\r\n\r\n              if (err) {\r\n                console.error('[SlackProtostub] error', err);\r\n                return resolve(false);\r\n              } else {\r\n                console.log('[SlackProtostub] PRESENCE OF USER', currentUser, data);\r\n                if (data.ok) {\r\n                  _this._toSubscribePresence.push(currentUser.id);\r\n                  console.log('[SlackProtostub] toSubscribeArray', _this._toSubscribePresence, 'intext', JSON.stringify(_this._toSubscribePresence));\r\n                  console.log('[SlackProtostub] resumed obj', reporterResumed);\r\n                  if (!reporterResumed) {\r\n                    let objPresence = _this._createNewObjPresence(data.presence);\r\n                    console.log('[SlackProtostub] creating a new contextReporter for invitedUSER ', objPresence, currentUser);\r\n                    //debugger;\r\n                    _this._contextReporter.create(currentUser.userURL, objPresence, ['availability_context'], currentUser.userURL, currentUser.userURL).then(function(context) {\r\n                      console.log('[SlackProtostub] CONTEXT RETURNED', context);\r\n                      context.onSubscription(function(event) {\r\n                        event.accept();\r\n                        console.log('[SlackProtostub] new subs', event);\r\n                      });\r\n                      _this._contextReportersInfo[currentUser.id] = context;\r\n                      return resolve(true);\r\n                    }).catch(function(err) {\r\n                      console.error('[SlackProtostub] err', err);\r\n                    });\r\n                  } else {\r\n                    console.log('[SlackProtostub] reporter for this userURL:', userURL, ' already exists ', reporterResumed);\r\n                    _this._contextReportersInfo[currentUser.id] = reporterResumed;\r\n                    return resolve(true);\r\n                  }\r\n\r\n                  console.log('[SlackProtostub] websocket readyState', _this._ws.readyState);\r\n\r\n                } else {\r\n                  return resolve(false);\r\n                }\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }).catch( function(error) {\r\n        console.log('[SlackProtostub] error', error);\r\n        return resolve(false);\r\n      });\r\n    });\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It returns a dataobject with info of a slack User\r\n  * @param {string} info - status info of a slackUser\r\n  * @return {object} return a object related with info of a slackUser\r\n  *******************************************************************************************************/\r\n  _createNewObjPresence(info) {\r\n    let _this = this;\r\n\r\n    return Object.assign({}, {\r\n        id: '_' + Math.random().toString(36).substr(2, 9),// do we need this?\r\n        values: [{\r\n            value: _this._getPresence(info),\r\n            name: 'availability',\r\n            type: 'availability_status',\r\n            unit: 'pres'\r\n        }]\r\n    });\r\n  };\r\n\r\n  /*****************************************************************************************************\r\n  * It returns a string with info related with presence of a user\r\n  * @param {string} info - status info of a slackUser\r\n  * @return {string} return info of presence of a slack user\r\n  *******************************************************************************************************/\r\n  _getPresence(info) {\r\n    let status;\r\n\r\n    if (info === \"active\") {\r\n      return 'available';\r\n\r\n    } else {\r\n      return 'unavailable';\r\n    }\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It get some info about channels, users, and groups of slack using token and returns info\r\n  * of who invite and who was invited\r\n  * @param {string} to - status info of a slackUser\r\n  * @param {string} ownID - status info of a slackUser\r\n  * @return {object} return object with info of who invite and who was invited\r\n  *******************************************************************************************************/\r\n  _getSlackInformation(to, ownID) {\r\n    let _this = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let URLUsersList = 'https://slack.com/api/users.list?token=' + _this._token;\r\n      //let URLGroupsList = 'https://slack.com/api/groups.list?token=' + _this._token;\r\n      let URLChannelsList = 'https://slack.com/api/channels.list?token=' + _this._token;\r\n      //let URLImsList = 'https://slack.com/api/im.list?token=' + _this._token;\r\n\r\n      let UsersListPromise = _this._sendHTTPRequest('GET', URLUsersList);\r\n      //let GroupsListPromise = _this._sendHTTPRequest('GET', URLGroupsList);\r\n      let ChannelsListPromise = _this._sendHTTPRequest('GET', URLChannelsList);\r\n      //let ImsListPromise = _this._sendHTTPRequest('GET', URLImsList);\r\n\r\n      Promise.all([UsersListPromise, ChannelsListPromise]).then(function(result) {\r\n      //Promise.all([UsersListPromise, GroupsListPromise, ChannelsListPromise, ImsListPromise]).then(function(result) {\r\n        _this._usersList = result[0].members;\r\n        //_this._groupsList = result[1].groups;\r\n        _this._channelsList = result[1].channels;\r\n        //_this._imsList = result[2].ims;\r\n\r\n        //get userID to invite\r\n        let toSplitted = to.split('://')[1];\r\n        let user = toSplitted.split('@')[0];\r\n        let invInfo = _this._usersList.filter(function(value) {\r\n          return value.name === user;\r\n        })[0];\r\n        let ownInfo = _this._usersList.filter(function(value) {\r\n          return value.id === ownID;\r\n        })[0];\r\n        let infotoReturn = {invInfo: invInfo, ownInfo:ownInfo}\r\n\r\n        resolve(infotoReturn);\r\n\r\n      }, function(error) {\r\n        console.error('[SlackProtostub] ', error);\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It check if channelexist, if user is on channel and check which users need to be invited\r\n  * @param {string} msg - message related with event received\r\n  * @param {Object} neededInfoInvited - info about user to be invited\r\n  * @param {Object} neededOwnInfo - info about user own info\r\n  *******************************************************************************************************/\r\n  _channelStatusInfo(msg, neededInfoInvited, neededOwnInfo) {\r\n    //_channelStatusInfo(msg, userID, channelObjUrl, userName, userURL, eventURL, identityToInv, ownUserURL, ownUserID) {\r\n    let _this = this;\r\n    let channelName = msg.value.name.split(' ').join('-').replace(/\\//gi, '-');\r\n    let channelExists = _this._channelsList.filter(function(value) { return value.name === channelName; })[0];\r\n    let channelMembers = null;\r\n    // if channel exist, invite user, else channel need to be created and then invite user\r\n    if (channelExists) {\r\n      console.log('[SlackProtostub] channel exist', channelExists);\r\n      channelMembers = _this._channelsList.filter(function(value) { return value.name === channelName; })[0].members;\r\n\r\n      let alreadyOnChannel = false;\r\n\r\n      channelMembers.forEach(function(s) {\r\n        if (s === neededInfoInvited.id) {\r\n          alreadyOnChannel = true;\r\n        }\r\n      });\r\n      console.log('[SlackProtostub] channel members', channelMembers, '   ->', alreadyOnChannel);\r\n\r\n\r\n      let count = 0;\r\n      let key = 0;\r\n      _this._subscribedList.forEach(function(obj) {\r\n        if (obj.urlDataObj === msg.url ) {\r\n          key = count;\r\n        }\r\n        count++;\r\n      });\r\n      console.log('[SlackProtostub] channels', _this._subscribedList, _this._subscribedList.length, key);\r\n      _this._subscribedList[key].channelID = channelExists.id;\r\n      //debugger;\r\n      // if user isnt on Channel invite, else just set channelID\r\n      if (!alreadyOnChannel) {\r\n        _this._invite(neededInfoInvited.id, channelExists.id);\r\n      }\r\n\r\n    } else {\r\n      _this._createChannel(channelName, msg.url).then(function(result) {\r\n        console.log('[SlackProtostub]  after create channel ', result );\r\n        if (result) {\r\n          _this._invite(neededInfoInvited.id,'',msg.url);\r\n        }\r\n\r\n      });\r\n    }\r\n      if (! _this._usersUpdated) {\r\n      _this._addAllUsersToHyperty(channelMembers, neededInfoInvited, neededOwnInfo);\r\n      //_this._addAllUsersToHyperty(channelMembers,userID, userURL, eventURL, userName, identityToInv, ownUserURL, ownUserID);\r\n    } else {\r\n      console.log('[SlackProtostub] users Already Updated');\r\n    }\r\n\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It add all users to dataobject and  create contextReporters for each one\r\n  * @param {Object[]} channelMembers - List of channel Members\r\n  * @param {Object} neededInfoInvited - info about user to be invited\r\n  * @param {Object} neededOwnInfo - info about user own info\r\n  *******************************************************************************************************/\r\n  _addAllUsersToHyperty(channelMembers, neededInfoInvited, neededOwnInfo) {\r\n    //_addAllUsersToHyperty(channelMembers, userID, userURL, eventURL, userName, identityToInv, ownUserURL, ownUserID) {\r\n    let _this = this;\r\n    _this._usersUpdated = true;\r\n    let usersInfo = {};\r\n    let toADD = [];\r\n    let userToAdd;\r\n    console.log('[SlackProtostub] lets check if users needs to be added');\r\n    if (channelMembers) {\r\n      _this._usersList.forEach(function(currentUser) {\r\n        channelMembers.forEach(function(s) {\r\n          //console.log('[SlackProtostub] currentUser', currentUser);\r\n          if (s === currentUser.id) {\r\n\r\n            if (neededInfoInvited.id != currentUser.id && neededOwnInfo.id != currentUser.id) {\r\n              console.log('[SlackProtostub] to add ', currentUser.id);\r\n              let identity = _this._factory.createMessageBodyIdentity(\r\n                currentUser.name,\r\n                'slack://slack.com/' + currentUser.name + '@slack.com',\r\n                currentUser.profile.image_192,\r\n                currentUser.name,\r\n                '', 'slack.com', undefined, currentUser.profile);\r\n\r\n              userToAdd = { user : 'slack://'+currentUser.name+'@slack.com', domain: 'slack.com', id: currentUser.id, userURL: 'slack://slack.com/'+currentUser.name+'@slack.com', identity: identity};\r\n              _this._addedUsersInfo.push(userToAdd);\r\n\r\n              toADD.push(userToAdd);\r\n            }\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    userToAdd = { user : 'slack://'+neededInfoInvited.name+'@slack.com', domain: 'slack.com', id: neededInfoInvited.id, userURL: 'slack://slack.com/'+neededInfoInvited.name+'@slack.com', identity: neededInfoInvited.identity};\r\n    _this._addedUsersInfo.push(userToAdd);\r\n    toADD.push(userToAdd);\r\n\r\n\r\n    toADD.forEach(function(user) {\r\n      console.log('[SlackProtostub] TEST joining with user', user);\r\n      if (user.userURL !== neededOwnInfo.userURL) {\r\n        _this._createNewContextReporter(user.userURL).then(function(creation){\r\n          //debugger;\r\n          if (creation == true) {\r\n            _this._chatManager.join(_this._dataObjectReporterURL, false, user.identity).then(function(result) {\r\n              console.log('[SlackProtostub] chatmanager JOIN', result, user.userURL, neededOwnInfo.userURL);\r\n              _this._prepareChat(result);\r\n              // if (user.userURL !== neededOwnInfo.userURL) {\r\n              //   _this._createNewContextReporter(user.userURL);\r\n              // }\r\n              let msgQuery = { \"type\": \"presence_sub\",\r\n                             \"ids\": _this._toSubscribePresence };\r\n              console.log('[SlackProtostub] websocket sentmessage', _this._ws.readyState, msgQuery);\r\n              _this._ws.send(JSON.stringify(msgQuery));\r\n\r\n            }).catch(function(error) {\r\n              console.log('[SlackProtostub] chatmanager JOIN error', error);\r\n            });\r\n          }\r\n        })\r\n      } else {\r\n        //TODO pode faltar aqui o chatmanager join\r\n      }\r\n\r\n    })\r\n\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It handle a new user added to a Slack channel, and add him to DataObject.participants\r\n  * @param {Object} message - message with a new user added\r\n  *******************************************************************************************************/\r\n  _handleNewUser(message) {\r\n    console.log('[SlackProtostub] Handling a new user', message);\r\n    let _this = this;\r\n    let subcribed;\r\n    _this._subscribedList.forEach(function(obj) {\r\n      if (obj.channelID === message.channel) {\r\n        subcribed = obj;\r\n      }\r\n    });\r\n    if (subcribed) {\r\n      let invInfo = _this._usersList.filter(function(value) {\r\n        return value.id === message.user;\r\n      })[0];\r\n\r\n      let identity = _this._factory.createMessageBodyIdentity(\r\n        invInfo.name,\r\n        'slack://slack.com/' + invInfo.name + '@slack.com',\r\n        invInfo.profile.image_192,\r\n        invInfo.name,\r\n        '', 'slack.com', undefined, invInfo.profile);\r\n\r\n      let userToAdd = { user : 'slack://'+invInfo.name+'@slack.com', domain: 'slack.com', id: message.user, userURL: 'slack://slack.com/'+invInfo.name+'@slack.com', identity: identity};\r\n      _this._addedUsersInfo.push(userToAdd);\r\n      console.log('[SlackProtostub] Joining chat',subcribed.urlDataObj, ' with', identity);\r\n      _this._createNewContextReporter(identity.userProfile.userURL).then(function(creation) {\r\n        //debugger;\r\n        if (creation == true) {\r\n          _this._chatManager.join(subcribed.urlDataObj, false, identity).then(function(result) {\r\n            _this._prepareChat(result);\r\n            let msgQuery = { \"type\": \"presence_sub\",\r\n                           \"ids\": _this._toSubscribePresence };\r\n            console.log('[SlackProtostub] websocket sentmessage', _this._ws.readyState, msgQuery);\r\n            _this._ws.send(JSON.stringify(msgQuery));\r\n            //_this._createNewContextReporter(identity.userProfile.userURL);\r\n          });\r\n        }\r\n      });\r\n\r\n    }\r\n\r\n\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It handle a new Presence change of Slack user, and change his status\r\n  * @param {Object} message - message with info about user and his status\r\n  *******************************************************************************************************/\r\n  _handlePresenceChange(message) {\r\n    let _this = this;\r\n    console.log('[SlackProtostub] updating presence of user');\r\n    if (_this._contextReportersInfo[message.user]) {\r\n      let reporter = _this._contextReportersInfo[message.user];\r\n      reporter.data.values[0].value = _this._getPresence(message.presence);\r\n      console.log('[SlackProtostub] presence of user', message.user, ' updated to', reporter.data);\r\n    }\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It handle a new message received on channel, and send it to hyperty\r\n  * @param {Object} message - message with info about channel and text to send\r\n  *******************************************************************************************************/\r\n  _handleNewMessage(message) {\r\n    console.log('[SlackProtostub] Handling a new message', message);\r\n    let _this = this;\r\n    let channelID = '';\r\n    let chat;\r\n    _this._subscribedList.forEach(function(obj) {\r\n      if (obj.channelID === message.channel) {\r\n        channelID = obj.channelID;\r\n        chat = obj.chat;\r\n      }\r\n    });\r\n    console.log('[SlackProtostub] subscribed list', _this._subscribedList);\r\n    if (message.channel && message.ts > _this._session.createdTime ) {\r\n      if (message.channel === channelID && message.user !== _this._id ||\r\n          (!message.hasOwnProperty('bot_id') && message.user === _this._id && message.channel === channelID)) {\r\n\r\n        _this._getUserInfo(message.user).then((identity) => {\r\n          console.log('[SlackProtostub] msg to addChild',  message.text, '     identity:', identity);\r\n          chat.send( message.text, identity);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It retrieves information from a slack user and creates a reTHINK Identity object with it\r\n  * @param {string} user - slack user id\r\n  * @return {Promise<Object>} Returns a promise with an Identity object resolved\r\n  *******************************************************************************************************/\r\n  _getUserInfo(user) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve) {\r\n      _this._slack.users.info({token: _this._token, user: user}, (err, data) => {\r\n        if (err) {\r\n          console.error('[SlackProtostub] error', err);\r\n        } else {\r\n\r\n          console.log('[SlackProtostub getUserInfo] ', data);\r\n          let identity = _this._factory.createMessageBodyIdentity(\r\n                    data.user.name,\r\n                    'slack://slack.com/' + data.user.name + '@slack.com',\r\n                    data.user.profile.image_192,\r\n                    data.user.name,\r\n                    '', 'slack.com');\r\n\r\n          resolve(identity);\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  _prepareChat(chat) {\r\n    let _this = this;\r\n    console.log('[SlackProtostub] chat', chat);\r\n    chat.onMessage((msg) => {\r\n      console.info('[SlackProtostub] onMessage: ', msg);\r\n      console.info('[SlackProtostub] Observer - Message History Control ', _this._messageHistoryControl);\r\n\r\n      //check if for each msg message has been delivered, and control that for when we have more than one slack user subscribed\r\n      let currentID = chat.child_cseq;\r\n      // check if this child already sent messages\r\n      let channelObjUrl = chat._dataObjectObserver.url;\r\n      let channelID;\r\n\r\n      _this._subscribedList.forEach(function(obj) {\r\n        if (obj.urlDataObj === channelObjUrl ) {\r\n          channelID = obj.channelID;\r\n        }\r\n      });\r\n\r\n      if( _this._messageHistoryControl.hasOwnProperty(channelObjUrl)) {\r\n\r\n        // in that case check if the currentID its equal to oldID\r\n        let oldID = _this._messageHistoryControl[channelObjUrl].id;\r\n        if ( oldID !== currentID ) {\r\n          _this._messageHistoryControl[channelObjUrl].id = currentID;\r\n          _this._deliver(msg, channelID);\r\n        }\r\n      } else {\r\n        _this._messageHistoryControl[channelObjUrl] = {id: currentID};\r\n        _this._deliver(msg, channelID);\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It retrieves information from a slack user and creates a reTHINK Identity object with it\r\n  * @param {string} idUser - slack user ID to be invited\r\n  * @param {string} idChannel - channelID for user will be invited\r\n  * @param {string} channelObjUrl - DataObjectURL from where user is invited\r\n  *******************************************************************************************************/\r\n  _invite(idUser, idChannel = '', channelObjUrl) {\r\n    let _this = this;\r\n\r\n    if (idChannel == '') {\r\n      _this._subscribedList.forEach(function(obj) {\r\n        if (obj.urlDataObj === channelObjUrl ) {\r\n          idChannel = obj.channelID;\r\n        }\r\n      });\r\n    }\r\n\r\n    let toInvite = { token: _this._token, channel: idChannel, user: idUser };\r\n\r\n    _this._slack.channels.invite(toInvite, (err, data) => {\r\n      if (err) {\r\n        console.error('[SlackProtostub] error', err);\r\n      } else {\r\n\r\n        console.log('[SlackProtostub] user invited with sucess', data);\r\n      }\r\n    });\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It deliver a message to a slack channel\r\n  * @param {Object} msg - Message Object\r\n  * @param {String} channelID - channelID to deliver message\r\n  *******************************************************************************************************/\r\n  _deliver(msg, channelID) {\r\n    let _this = this;\r\n\r\n    console.log('[SlackProtostub] Msg to Deliver: ',msg, ' on channel:', channelID);\r\n    if (channelID && msg.value) {\r\n\r\n      if (msg.hasOwnProperty('identity') && msg.identity.hasOwnProperty('userProfile')\r\n      && msg.identity.userProfile.hasOwnProperty('name') && msg.identity.userProfile.name) {\r\n\r\n        let text = '' + msg.identity.userProfile.name + ': ' + msg.value.content;\r\n        let message = { as_user: true, token: _this._token, channel: channelID, text: text};\r\n        console.log('[SlackProtostub] (PostMessage slack api) token(', _this._token, ')  channel(', channelID, ') text(',  msg.value.content, ')');\r\n\r\n        // call Slack postMessage method to deliver msg on slack channel\r\n        _this._slack.chat.postMessage(message, function(err, data) {\r\n          if (err) {\r\n            if (err.message == 'not_in_channel') {\r\n              console.error('[SlackProtostub] Channel exist, but user is not on channel', err)\r\n              let channelToJoin = _this._channelsList.filter(function(value) {\r\n                return value.id === channelID;\r\n              })[0];\r\n              let objToJoin = { token: _this._token, name: channelToJoin.name};\r\n\r\n              _this._slack.channels.join(objToJoin);\r\n              _this._deliver(msg, channelID);\r\n            } else {\r\n              console.error('[SlackProtostub] error', err);\r\n            }\r\n          } else {\r\n            console.log('[SlackProtostub] PostMessage with Sucess', data);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It create a new slackChannel using channelName\r\n  * @param {String} channelName - name to be used to create a new channel\r\n  * @param {String} channelObjUrl - Dataobject URL of a channel to be used to associate this channel to this dataobject\r\n  *******************************************************************************************************/\r\n  _createChannel(channelName, channelObjUrl) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve) {\r\n      let toCreate = { token: _this._token, name: channelName };\r\n      console.log('[SlackProtostub] Creating a new channel toCreate:',toCreate, '  channelObjUrl:',  channelObjUrl);\r\n      _this._slack.channels.create(toCreate, (err, data) => {\r\n        if (err) {\r\n          console.error('[SlackProtostub] ', err);\r\n        } else {\r\n          if (data.ok) {\r\n            console.log('[SlackProtostub] Channel Created with Sucess ', data);\r\n            console.log('[SlackProtostub] Associate a new channel ID', data.channel.id, 'to urlDataObj',  channelObjUrl);\r\n\r\n            let count = 0;\r\n            let key = 0;\r\n            //Associate a channel to comm dataObject\r\n            _this._subscribedList.forEach(function(obj) {\r\n              if (obj.urlDataObj === channelObjUrl ) {\r\n                key = count;\r\n              }\r\n              count++;\r\n            });\r\n            _this._subscribedList[key].channelID = data.channel.id;\r\n            console.log('[SlackProtostub] subscribed list', _this._subscribedList);\r\n            resolve(true);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  _sendHTTPRequest(method, url) {\r\n    return new Promise(function(resolve, reject) {\r\n      let xhr = new XMLHttpRequest();\r\n      if ('withCredentials' in xhr) {\r\n        xhr.open(method, url, true);\r\n      } else if (typeof XDomainRequest !== 'undefined') {\r\n        // Otherwise, check if XDomainRequest.\r\n        // XDomainRequest only exists in IE, and is IE's way of making CORS requests.\r\n        xhr = new XDomainRequest();\r\n        xhr.open(method, url);\r\n      } else {\r\n        // Otherwise, CORS is not supported by the browser.\r\n        xhr = null;\r\n      }\r\n      if (xhr) {\r\n        xhr.onreadystatechange = function() {\r\n          if (xhr.readyState === 4) {\r\n            if (xhr.status === 200) {\r\n              let info = JSON.parse(xhr.responseText);\r\n              resolve(info);\r\n            } else if (xhr.status === 400) {\r\n              reject('There was an error processing the token');\r\n            } else {\r\n              reject('something else other than 200 was returned');\r\n            }\r\n          }\r\n        };\r\n        xhr.send();\r\n      } else {\r\n        reject('CORS not supported');\r\n      }\r\n    });\r\n  }\r\n\r\n  /*****************************************************************************************************\r\n  * It Updates the state of ProtoStub\r\n  * @param {String} value - status of protostub to be updated\r\n  * @param {String} reason - reason of this update, optional\r\n  *******************************************************************************************************/\r\n  _sendStatus(value, reason) {\r\n    let _this = this;\r\n\r\n    console.log('[SlackProtostub status changed] to ', value);\r\n\r\n    _this._state = value;\r\n\r\n    let msg = {\r\n      type: 'update',\r\n      from: _this._myUrl,\r\n      to: _this._myUrl + '/status',\r\n      body: {\r\n        value: value\r\n      }\r\n    };\r\n\r\n    if (reason) {\r\n      msg.body.desc = reason;\r\n    }\r\n    _this._bus.postMessage( msg );\r\n  }\r\n}\r\n\r\n\r\n/*export default function activate(url, bus, config, factory) {\r\n  return {\r\n    name: 'SlackProtoStub',\r\n    instance: new SlackProtoStub(url, bus, config, factory)\r\n  };\r\n}*/\r\n\n\n//# sourceURL=webpack:///./src/protostub/slack/slack.slack.com.ps.js?");

/***/ })

/******/ })
			);
		}
	};
});