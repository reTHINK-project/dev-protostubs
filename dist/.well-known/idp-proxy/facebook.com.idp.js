System.register([], function(__WEBPACK_DYNAMIC_EXPORT__) {

	return {

		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/idpproxy/facebook/facebook.com.idp.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/idpproxy/AbstractIdpProxyStub.js":
/*!**********************************************!*\
  !*** ./src/idpproxy/AbstractIdpProxyStub.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet IdpProxy;\r\nlet idpInfo;\r\nlet convertUserProfile;\r\nlet userInfoEndpoint;\r\nlet accessTokenInput;\r\n\r\n/**\r\n* Abstract Identity Provider Proxy Protocol Stub to be extended by real Idp Proxies\r\n*/\r\nclass AbstractIdpProxyProtoStub {\r\n\r\n  /**\r\n  * Constructor of the IdpProxy Stub\r\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\r\n  *\r\n  * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n  * @param  {Message.Message}                           busPostMessage     configuration\r\n  * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n  */\r\n  constructor() {\r\n    console.log('[AbstractIdpProxy] constructor');\r\n  }\r\n\r\n  _init(runtimeProtoStubURL, bus, config) {\r\n    let _this = this;\r\n    _this.runtimeProtoStubURL = runtimeProtoStubURL;\r\n    _this.messageBus = bus;\r\n    _this.config = config;\r\n    IdpProxy = config.idpProxy;\r\n    convertUserProfile = config.convertUserProfile;\r\n    accessTokenInput = config.accessTokenInput;\r\n\r\n\r\n\r\n    _this.messageBus.addListener('*', function (msg) {\r\n      if (msg.to === config.idpUrl) {\r\n\r\n        _this.requestToIdp(msg);\r\n      }\r\n    });\r\n    _this._sendStatus('created');\r\n  }\r\n\r\n  /**\r\n  * Function that see the intended method in the message received and call the respective function\r\n  *\r\n  * @param {message}  message received in the messageBus\r\n  */\r\n  requestToIdp(msg) {\r\n    let _this = this;\r\n    let params = msg.body.params;\r\n    //console.info('requestToIdp:', msg.body.method);\r\n    console.info('[AbstractIdpProxyProtoStub] receiving request: ', msg);\r\n\r\n    switch (msg.body.method) {\r\n      case 'generateAssertion':\r\n        IdpProxy.generateAssertion(_this.config, params.contents, params.origin, params.usernameHint).then(\r\n          function (value) {\r\n\r\n            value.userProfile = convertUserProfile(value.userProfile);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'validateAssertion':\r\n        //       console.info('validateAssertion');\r\n        IdpProxy.validateAssertion(_this.config, params.assertion, params.origin).then(\r\n          function (value) { _this.replyMessage(msg, value); },\r\n\r\n          function (error) { _this.replyMessage(msg, error); }\r\n        );\r\n        break;\r\n      case 'refreshAssertion':\r\n        //     console.info('refreshAssertion');\r\n        IdpProxy.refreshAssertion(params.identity).then(\r\n          function (value) { _this.replyMessage(msg, value); },\r\n\r\n          function (error) { _this.replyMessage(msg, error, value, 401); }\r\n        );\r\n        break;\r\n      case 'getAccessTokenAuthorisationEndpoint':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.getAccessTokenAuthorisationEndpoint(_this.config, params.resources).then(\r\n          function (value) {\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'getAccessToken':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.getAccessToken(_this.config, params.resources, params.login).then(\r\n          function (value) {\r\n            console.info('OIDC.getAccessToken result: ', value);\r\n            value.input = accessTokenInput(value.input);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'refreshAccessToken':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.refreshAccessToken(_this.config, params.token).then(\r\n          function (value) {\r\n            console.info('OIDC.refreshAccessToken result: ', value);\r\n//            value.input = accessTokenInput(value.input);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'revokeAccessToken':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.revokeAccessToken(_this.config, params.token).then(\r\n          function (value) {\r\n            console.info('OIDC.revokeAccessToken result: ', value);\r\n//            value.input = accessTokenInput(value.input);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function receives a message and a value. It replies the value to the sender of the message received\r\n  *\r\n  * @param  {message}   message received\r\n  * @param  {value}     value to include in the new message to send\r\n  */\r\n  replyMessage(msg, value, code = 200) {\r\n    let _this = this;\r\n\r\n    let message = {\r\n      id: msg.id, type: 'response', to: msg.from, from: msg.to,\r\n      body: { code: code }\r\n    };\r\n\r\n    if (code < 300 ) message.body.value = value;\r\n    else message.body.description = value;\r\n\r\n    console.log('[AbstractIdpProxyProtoStub.replyMessage] ', message);\r\n\r\n    _this.messageBus.postMessage(message);\r\n  }\r\n\r\n  _sendStatus(value, reason) {\r\n    let _this = this;\r\n\r\n    console.log('[AbstractIdpProxyProtoStub.sendStatus] ', value);\r\n\r\n    _this._state = value;\r\n\r\n    let msg = {\r\n      type: 'update',\r\n      from: _this.runtimeProtoStubURL,\r\n      to: _this.runtimeProtoStubURL + '/status',\r\n      body: {\r\n        value: value\r\n      }\r\n    };\r\n\r\n    if (reason) {\r\n      msg.body.desc = reason;\r\n    }\r\n\r\n    _this.messageBus.postMessage(msg);\r\n  }\r\n}\r\n\r\n// export default IdpProxyProtoStub;\r\n\r\n/**\r\n * To activate this protocol stub, using the same method for all protostub.\r\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n * @param  {Message.Message}                           busPostMessage     configuration\r\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n * @return {Object} Object with name and instance of ProtoStub\r\n */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AbstractIdpProxyProtoStub);\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/AbstractIdpProxyStub.js?");

/***/ }),

/***/ "./src/idpproxy/OAUTH.js":
/*!*******************************!*\
  !*** ./src/idpproxy/OAUTH.js ***!
  \*******************************/
/*! exports provided: getExpiresAtJSON, getExpires, IdpProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getExpiresAtJSON\", function() { return getExpiresAtJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getExpires\", function() { return getExpires; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IdpProxy\", function() { return IdpProxy; });\n\r\n//let identities = {};\r\n//let nIdentity = 0;\r\n//let redirectURI = location.protocol + '//' + location.hostname + (location.port !== '' ? ':' + location.port : '');\r\nlet userInfoEndpoint;\r\nlet tokenEndpoint;\r\nlet authorisationEndpoint;\r\nlet domain;\r\nlet accessTokenEndpoint;\r\nlet accessTokenAuthorisationEndpoint;\r\nlet refreshAccessTokenEndpoint;\r\nlet revokeAccessTokenEndpoint;\r\n\r\nlet getExpiresAtJSON = (function (json) {\r\n  let expires = json.hasOwnProperty('expires_in') ? json.expires_in : false\r\n\r\n  if (expires) expires = expires + Math.floor(Date.now() / 1000);\r\n  else expires = 3153600000 + Math.floor(Date.now() / 1000);\r\n\r\n  return Number(expires);\r\n\r\n});\r\n\r\n//function to parse the query string in the given URL to obatin certain values\r\nfunction urlParser(url, name) {\r\n  name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\r\n  let regexS = '[\\\\#&?]' + name + '=([^&#]*)';\r\n  let regex = new RegExp(regexS);\r\n  let results = regex.exec(url);\r\n  if (results === null)\r\n    return '';\r\n  else\r\n    return results[1];\r\n}\r\n\r\nfunction sendHTTPRequest(method, url) {\r\n  let xhr = new XMLHttpRequest();\r\n  if ('withCredentials' in xhr) {\r\n    xhr.open(method, url, true);\r\n  } else if (typeof XDomainRequest != 'undefined') {\r\n    // Otherwise, check if XDomainRequest.\r\n    // XDomainRequest only exists in IE, and is IE's way of making CORS requests.\r\n    xhr = new XDomainRequest();\r\n    xhr.open(method, url);\r\n  } else {\r\n    // Otherwise, CORS is not supported by the browser.\r\n    xhr = null;\r\n  }\r\n  return new Promise(function (resolve, reject) {\r\n    if (xhr) {\r\n      xhr.onreadystatechange = function (e) {\r\n        console.log('[OAUTH2.sendHTTPRequest] response ', e);\r\n        if (xhr.readyState === 4) {\r\n          if (xhr.status === 200) {\r\n            let info = JSON.parse(xhr.responseText);\r\n            resolve(info);\r\n          } else if (xhr.status === 400) {\r\n            reject('There was an error processing the token');\r\n          } else if (xhr.status === 401) {\r\n            reject('Not Authorised');\r\n          } else {\r\n            reject('something else other than 200 was returned');\r\n          }\r\n        }\r\n      };\r\n      xhr.send();\r\n    } else {\r\n      reject('CORS not supported');\r\n    }\r\n  });\r\n}\r\n\r\nlet exchangeRefreshToken = (function (refreshToken) {\r\n  let i = googleInfo;\r\n\r\n  let URL = i.tokenEndpoint + 'client_id=' + i.clientID + '&client_secret=' + i.clientSecret + '&refresh_token=' + refreshToken + '&grant_type=refresh_token';\r\n\r\n  return new Promise(function (resolve, reject) {\r\n    sendHTTPRequest('POST', URL).then(function (info) {\r\n      resolve(info);\r\n    }, function (error) {\r\n      reject(error);\r\n    });\r\n\r\n  });\r\n});\r\n\r\nlet generateAssertionWithAccessToken = (function (contents, expires, info) {\r\n\r\n  return new Promise(function (resolve, reject) {\r\n    sendHTTPRequest('GET', userInfoEndpoint(info)).then(function (infoToken) {\r\n      console.log('[OAUTH2.generateAssertion] obtained user profile ', infoToken);\r\n\r\n      let assertion = btoa(JSON.stringify({ tokenID: info.access_token, tokenIDJSON: infoToken, publicKey: contents }));\r\n      console.log('[OAUTH2.generateAssertion] atob assertion:', atob(assertion));\r\n      let idpBundle = { domain: domain, protocol: 'OAUTH2' };\r\n\r\n      //TODO delete later the field infoToken, and delete the need in the example\r\n      let returnValue = { assertion: assertion, idp: idpBundle, expires: expires, userProfile: infoToken };\r\n\r\n      /*      identities[nIdentity] = returnValue;\r\n            ++nIdentity;\r\n      */\r\n      console.log('[OAUTH2.generateAssertion] returning: ', JSON.stringify(returnValue));\r\n\r\n      resolve(returnValue);\r\n    });\r\n  });\r\n});\r\n\r\nlet generateAssertionWithCodeToken = (function (contents, expires, hint) {\r\n  return new Promise(function (resolve, reject) {\r\n    let code = urlParser(hint, 'code');\r\n\r\n    if (!code) reject('[OAUTH2.generateAssertionWithCode] code not returned by the authentication: ', hint);\r\n\r\n    sendHTTPRequest('POST', tokenEndpoint(code)).then(function (info) {\r\n\r\n      if (info.hasOwnProperty('access_token'))\r\n        resolve(generateAssertionWithAccessToken(contents, expires, info));\r\n      else reject('[OAUTH2.generateAssertionWithCode] access token not returned in the exchange code result: ', info);\r\n    }, function (error) {\r\n      reject(error);\r\n    });\r\n\r\n  });\r\n});\r\n\r\nlet getAccessTokenWithCodeToken = (function (resources, login) {\r\n  return new Promise(function (resolve, reject) {\r\n    let code = urlParser(login, 'code');\r\n\r\n    if (!code) reject('[OAUTH2.getAccessTokenWithCodeToken] code not returned by the login result: ', login);\r\n\r\n    sendHTTPRequest('POST', accessTokenEndpoint(code, resources)).then(function (info) {\r\n\r\n    console.info('[OAUTH2.getAccessTokenWithCodeToken] HTTP response: ', info);\r\n\r\n      if (info.hasOwnProperty('access_token')) {\r\n        let expires = getExpires(info);\r\n        let refresh = info.hasOwnProperty('refresh_token') ? info.refresh_token : false;\r\n        resolve(accessTokenResult(resources, info.access_token, expires, info, refresh));\r\n      } else reject('[OAUTH2.getAccessTokenWithCodeToken] access token not returned in the exchange code result: ', info);\r\n    }, function (error) {\r\n      reject(error);\r\n    });\r\n\r\n  });\r\n});\r\n\r\nlet getExpires = (function (url) {\r\n  let expires = urlParser(url, 'expires_in');\r\n\r\n  if (expires) expires = expires + Math.floor(Date.now() / 1000);\r\n  else expires = 3153600000 + Math.floor(Date.now() / 1000);\r\n\r\n  return expires;\r\n\r\n});\r\n\r\n\r\nlet accessTokenResult = (function (resources, accessToken, expires, input, refresh) {\r\n\r\n  let result = { domain: domain, resources: resources, accessToken: accessToken, expires: expires, input: input };\r\n\r\n  if (refresh) result.refresh = refresh;\r\n\r\n  return result;\r\n\r\n});\r\n\r\n/**\r\n* Identity Provider Proxy\r\n*/\r\nlet IdpProxy = {\r\n\r\n  /**\r\n  * Function to validate an identity Assertion received\r\n  * TODO add details of the implementation, and improve the implementation\r\n  *\r\n  * @param  {idpInfo}      Object information about IdP endpoints\r\n  * @param  {assertion}    Identity Assertion to be validated\r\n  * @param  {origin}       Origin parameter that identifies the origin of the RTCPeerConnection\r\n  * @return {Promise}      Returns a promise with the identity assertion validation result\r\n  */\r\n  validateAssertion: (config, assertion, origin) => {\r\n    console.info('[OAUTH2.validateAssertion] assertion: ', atob(assertion));\r\n    userInfoEndpoint = config.userInfoEndpoint;\r\n    domain = config.domain;\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      //      let i = idpInfo;\r\n      let decodedContent = atob(assertion);\r\n      let content = JSON.parse(decodedContent);\r\n      sendHTTPRequest('GET', config.validateAssertionEndpoint({ access_token: content.tokenID, input: content.tokenIDJSON })).then(result => {\r\n        if (JSON.stringify(result) === JSON.stringify(content.tokenIDJSON)) {\r\n          //        if (result.hasOwnProperty('name')) {\r\n          resolve({ identity: config.convertUserProfile(result).id, contents: content.publicKey });\r\n        } else {\r\n          reject('invalid');\r\n        }\r\n      }).catch(err => {\r\n        reject(err);\r\n      });\r\n    });\r\n  },\r\n  /*\r\n    refreshAssertion: (identity) => {\r\n      //console.log('PROXY:refreshAssertion:oldIdentity', identity);\r\n      let i = googleInfo;\r\n  \r\n      return new Promise(function(resolve, reject) {\r\n        if (identity.info.refreshToken) {\r\n          exchangeRefreshToken(identity.info.refreshToken).then(function(value) {\r\n            let infoTokenURL = i.userinfo + value.access_token;\r\n            sendHTTPRequest('GET', infoTokenURL).then(function(infoToken) {\r\n  \r\n              let identityBundle = {accessToken: value.access_token, idToken: value.id_token, refreshToken: identity.info.refreshToken, tokenType: identity.info.tokenType, infoToken: infoToken};\r\n              let idTokenURL = i.tokenInfo + value.id_token;\r\n  \r\n              //obtain information about the user idToken\r\n              sendHTTPRequest('GET', idTokenURL).then(function(idToken) {\r\n  \r\n                identityBundle.tokenIDJSON = idToken;\r\n                identityBundle.expires = idToken.exp;\r\n                identityBundle.email = idToken.email;\r\n  \r\n                let oldIDToken = JSON.parse(atob(identity.assertion));\r\n                let oldIdTokenSplited = oldIDToken.tokenID.split('.');\r\n                let oldDecodedIDToken = JSON.parse(atob(oldIdTokenSplited[1]));\r\n                let idNonce = oldDecodedIDToken.nonce;\r\n  \r\n                let receivedIDToken = value.id_token;\r\n                let idTokenSplited = receivedIDToken.split('.');\r\n                let decodedIDToken = JSON.parse(atob(idTokenSplited[1]));\r\n  \r\n                decodedIDToken.nonce = idNonce;\r\n                let insertedNonce = btoa(JSON.stringify(decodedIDToken));\r\n                let newIDToken = idTokenSplited[0] + '.' +\r\n                                   insertedNonce + '.' +\r\n                                   idTokenSplited[2];\r\n  \r\n                let assertion = btoa(JSON.stringify({tokenID: newIDToken, tokenIDJSON: idToken}));\r\n                let idpBundle = {domain: 'google.com', protocol: 'OIDC'};\r\n  \r\n                //TODO delete later the field infoToken, and delete the need in the example\r\n                let returnValue = {assertion: assertion, idp: idpBundle, info: identityBundle, infoToken: infoToken};\r\n                //console.log('PROXY:refreshAssertion:newIdentity', returnValue);\r\n                resolve(returnValue);\r\n              });\r\n            });\r\n          });\r\n        }\r\n      });\r\n    },*/\r\n\r\n  /**\r\n  * Function to generate an identity Assertion\r\n  *\r\n  * @param  {idpInfo}      Object information about IdP endpoints\r\n  * @param  {contents} The contents includes information about the identity received\r\n  * @param  {origin} Origin parameter that identifies the origin of the RTCPeerConnection\r\n  * @param  {usernameHint} optional usernameHint parameter\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n  generateAssertion: (config, contents, origin, hint) => {\r\n    console.log('[OAUTH2.generateAssertion:config]', config);\r\n    console.log('[OAUTH2.generateAssertion:contents]', contents);\r\n    console.log('[OAUTH2.generateAssertion:origin]', origin);\r\n    console.log('[OAUTH2.generateAssertion:hint]', hint);\r\n    //    let i = idpInfo;\r\n    userInfoEndpoint = config.userInfoEndpoint;\r\n    tokenEndpoint = config.tokenEndpoint;\r\n    authorisationEndpoint = config.authorisationEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      if (!hint) {\r\n\r\n        //        console.log('[OAUTH2.generateAssertion] NO_HINT: rejecting with requestUrl ', requestUrl);\r\n\r\n        reject({ name: 'IdPLoginError', loginUrl: authorisationEndpoint(contents) });\r\n\r\n      } else {\r\n        // the request have already been made, so idpPRoxy will try to access the user information\r\n        let expires = urlParser(hint, 'expires_in');\r\n\r\n        if (expires) expires = expires + Math.floor(Date.now() / 1000);\r\n        else expires = 3153600000 + Math.floor(Date.now() / 1000);\r\n\r\n        let accessToken = urlParser(hint, 'access_token');\r\n\r\n        if (accessToken) resolve(generateAssertionWithAccessToken(contents, expires, { access_token: accessToken }));\r\n        else resolve(generateAssertionWithCodeToken(contents, expires, hint));\r\n      }\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n\r\n  /**\r\n  * Function to get an Access Token\r\n  *\r\n  * @param  {config}      Object information about IdP endpoints\r\n  * @param  {resources} Object contents includes information about the identity received\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n\r\n  getAccessTokenAuthorisationEndpoint: (config, resources) => {\r\n    console.log('[OAUTH2.getAccessTokenAuthorisationEndpoint:config]', config);\r\n    //    console.log('[OAUTH2.generateAssertion:contents]', contents);\r\n    //    console.log('[OAUTH2.generateAssertion:origin]', origin);\r\n    console.log('[OAUTH2.getAccessTokenAuthorisationEndpoint:resources]', resources);\r\n    //    let i = idpInfo;\r\n    accessTokenAuthorisationEndpoint = config.accessTokenAuthorisationEndpoint;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n\r\n      resolve(accessTokenAuthorisationEndpoint(resources));\r\n\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n\r\n  /**\r\n  * Function to get an Access Token\r\n  *\r\n  * @param  {config} Object information about OAUTH server endpoints\r\n  * @param  {login} optional login result\r\n  * @param  {resources} Object resources to be authorised\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n\r\n  getAccessToken: (config, resources, login) => {\r\n    console.log('[OAUTH2.getAccessToken:config]', config);\r\n    //    console.log('[OAUTH2.generateAssertion:contents]', contents);\r\n    //    console.log('[OAUTH2.generateAssertion:origin]', origin);\r\n    console.log('[OAUTH2.getAccessToken:login]', login);\r\n    //    let i = idpInfo;\r\n    accessTokenEndpoint = config.accessTokenEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // the user is loggedin, try to extract the Access Token and its expires\r\n      let expires = getExpires(login);\r\n\r\n      let accessToken = urlParser(login, 'access_token');\r\n\r\n      if (accessToken) resolve(accessTokenResult(resources, accessToken, expires, login));\r\n      else resolve(getAccessTokenWithCodeToken(resources, login));\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n\r\n/**\r\n  * Function to refresh an Access Token\r\n  *\r\n  * @param  {login} optional login result\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n\r\n refreshAccessToken: (config, token) => {\r\n    console.log('[OAUTH2.refreshAccessToken:config]', config);\r\n    //    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    //    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OAUTH2.refreshAccessToken:outdated token]', token);\r\n    //    let i = idpInfo;\r\n    refreshAccessTokenEndpoint = config.refreshAccessTokenEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // the user is loggedin, try to extract the Access Token and its expires\r\n\r\n      let refresh = token.refresh;\r\n\r\n      if (!refresh) reject('[OAUTH2.refreshAccessToken] refresh token not available in the access token', token);\r\n\r\n      sendHTTPRequest('POST', refreshAccessTokenEndpoint(refresh)).then(function (info) {\r\n\r\n        console.info('[OAUTH2.refreshAccessToken] response: ', info);\r\n\r\n        if (info.hasOwnProperty('access_token')) {\r\n\r\n          let expires = getExpiresAtJSON(info);\r\n          resolve(accessTokenResult(token.resources, info.access_token, expires, info, refresh));\r\n        } else reject('[OAUTH2.refreshAccessToken] new access token not returned in the response: ', info);\r\n      }, function (error) {\r\n        reject(error);\r\n      });\r\n\r\n      //      });\r\n\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n\r\n/**\r\n    * Function to remove an Access Token\r\n    *\r\n    * @param  {config} JSON oauth API configuration\r\n    * @param  {config} string access token to be revoked\r\n    * @return {Promise} returns a promise with an identity assertion\r\n    */\r\n\r\n   revokeAccessToken: (config, token) => {\r\n    console.log('[OAUTH2.revokeAccessToken:config]', config);\r\n    //    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    //    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OAUTH2.revokeAccessToken: token]', token);\r\n    //    let i = idpInfo;\r\n    revokeAccessTokenEndpoint = config.revokeAccessTokenEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // the user is loggedin, try to extract the Access Token and its expires\r\n\r\n      let refresh = token.refresh;\r\n\r\n      if (!refresh) reject('[OAUTH2.revokeAccessToken] refresh token not available in the access token', token);\r\n\r\n      sendHTTPRequest('POST', revokeAccessTokenEndpoint(token.accessToken)).then(function (info) {\r\n\r\n        console.info('[OAUTH2.revokeAccessToken] response: ', info);\r\n\r\n        resolve(true);\r\n      }, function (error) {\r\n        reject(error);\r\n      });\r\n\r\n      //      });\r\n\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  }\r\n};\r\n\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/OAUTH.js?");

/***/ }),

/***/ "./src/idpproxy/facebook/Facebook.js":
/*!*******************************************!*\
  !*** ./src/idpproxy/facebook/Facebook.js ***!
  \*******************************************/
/*! exports provided: convertUserProfile, userInfoEndpoint, authorisationEndpoint, validateAssertionEndpoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertUserProfile\", function() { return convertUserProfile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"userInfoEndpoint\", function() { return userInfoEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorisationEndpoint\", function() { return authorisationEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateAssertionEndpoint\", function() { return validateAssertionEndpoint; });\n\r\n/*\r\n\tSo that an application can use Facebook's OAuth 2.0 authentication system for user login,\r\n  first is required to set up a project in the Facebook Developers Console (https://developers.facebook.com/apps/) \r\n  to obtain OAuth 2.0 credentials and set a redirect URI.\r\n */\r\nlet redirectURI = location.protocol + '//' + location.hostname + (location.port !== '' ? ':' + location.port : '');\r\n\r\nlet facebookInfo = {\r\n  \"clientID\":             \"516850078685290\",\r\n  \"authorisationEndpoint\": \"https://www.facebook.com/v2.11/dialog/oauth?\",\r\n  \"userinfo\":              \"https://graph.facebook.com/v2.2/me/?fields=id,first_name,last_name,name,picture,email&access_token=\",\r\n  \"type\":                  \"token\",\r\n  \"granted_scopes\":        \"email,public_profile\",\r\n  \"state\":                 \"state\",\r\n  \"domain\":                \"facebook.com\"\r\n};\r\n\r\n\r\n\r\n// function to convert google user profile info into standard reTHINK user profile object\r\n\r\nfunction convertUserProfile(userProfile) {\r\n\r\n  console.log('[FaceboolUserProfileConverter] ', userProfile );\r\n  userProfile.name = userProfile.first_name + ' ' + userProfile.last_name;\r\n\r\n  userProfile.userURL = 'user://facebook.com/' + userProfile.name;\r\n\r\n  userProfile.picture = userProfile.picture.data.url;\r\n\r\n  if (!userProfile.hasOwnProperty('preferred_username')) \r\n  userProfile.preferred_username = userProfile.last_name;\r\n\r\n\r\n  return userProfile;\r\n}\r\n\r\n\r\n\r\nfunction userInfoEndpoint(info) {\r\n\r\n  return facebookInfo.userinfo + info.access_token;\r\n\r\n}\r\n\r\nfunction authorisationEndpoint(nonce) {\r\n\r\n  let url = facebookInfo.authorisationEndpoint \r\n    + 'redirect_uri=' + redirectURI\r\n    + '&response_type=' + facebookInfo.type\r\n    + '&client_id=' + facebookInfo.clientID\r\n    + '&granted_scopes=' + facebookInfo.granted_scopes\r\n    + '&nonce=' + nonce\r\n    + '&state=' + nonce;\r\n  console.log('[Slack.authorisationEndpoint] ', url);\r\n  return url;\r\n}\r\n\r\nfunction validateAssertionEndpoint(info) {\r\n\r\n  return facebookInfo.userinfo + info.access_token;\r\n\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/facebook/Facebook.js?");

/***/ }),

/***/ "./src/idpproxy/facebook/facebook.com.idp.js":
/*!***************************************************!*\
  !*** ./src/idpproxy/facebook/facebook.com.idp.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _OAUTH_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../OAUTH.js */ \"./src/idpproxy/OAUTH.js\");\n/* harmony import */ var _Facebook_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Facebook.js */ \"./src/idpproxy/facebook/Facebook.js\");\n/* harmony import */ var _AbstractIdpProxyStub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AbstractIdpProxyStub.js */ \"./src/idpproxy/AbstractIdpProxyStub.js\");\n\r\n//import {facebookInfo} from \"./FacebookInfo\"\r\n\r\n\r\n\r\n\r\n/**\r\n* Google Identity Provider Proxy Protocol Stub\r\n*/\r\nclass FacebookIdpProxyProtoStub extends _AbstractIdpProxyStub_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n\r\n  /**\r\n  * Constructor of the IdpProxy Stub\r\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\r\n  *\r\n  * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n  * @param  {Message.Message}                           busPostMessage     configuration\r\n  * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n  */\r\n constructor() {\r\n  super();\r\n\r\n }\r\n\r\n _start(runtimeProtoStubURL, bus, config) {\r\n    config.idpUrl = 'domain-idp://facebook.com';\r\n    config.domain = 'facebook.com';\r\n    config.idpProxy = _OAUTH_js__WEBPACK_IMPORTED_MODULE_0__[\"IdpProxy\"];\r\n    //     config.idpInfo = facebookInfo;\r\n    config.convertUserProfile = _Facebook_js__WEBPACK_IMPORTED_MODULE_1__[\"convertUserProfile\"];\r\n    config.userInfoEndpoint = _Facebook_js__WEBPACK_IMPORTED_MODULE_1__[\"userInfoEndpoint\"];\r\n    config.authorisationEndpoint = _Facebook_js__WEBPACK_IMPORTED_MODULE_1__[\"authorisationEndpoint\"];\r\n    config.validateAssertionEndpoint = _Facebook_js__WEBPACK_IMPORTED_MODULE_1__[\"validateAssertionEndpoint\"];\r\n    super._init(runtimeProtoStubURL, bus, config);\r\n  }\r\n}\r\n\r\n// export default IdpProxyProtoStub;\r\n\r\n/**\r\n * To activate this protocol stub, using the same method for all protostub.\r\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n * @param  {Message.Message}                           busPostMessage     configuration\r\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n * @return {Object} Object with name and instance of ProtoStub\r\n */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FacebookIdpProxyProtoStub);\r\n\r\n/*export default function activate(url, bus, config) {\r\n  return {\r\n    name: 'FacebookIdpProxyProtoStub',\r\n    instance: new FacebookIdpProxyProtoStub(url, bus, config)\r\n  };\r\n}*/\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/facebook/facebook.com.idp.js?");

/***/ })

/******/ })
			);
		}
	};
});