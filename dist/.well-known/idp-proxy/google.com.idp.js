System.register([], function(__WEBPACK_DYNAMIC_EXPORT__) {

	return {

		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/idpproxy/google/google.com.idp.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/idpproxy/AbstractIdpProxyStub.js":
/*!**********************************************!*\
  !*** ./src/idpproxy/AbstractIdpProxyStub.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet IdpProxy;\r\nlet idpInfo;\r\nlet convertUserProfile;\r\nlet userInfoEndpoint;\r\nlet accessTokenInput;\r\n\r\n/**\r\n* Abstract Identity Provider Proxy Protocol Stub to be extended by real Idp Proxies\r\n*/\r\nclass AbstractIdpProxyProtoStub {\r\n\r\n  /**\r\n  * Constructor of the IdpProxy Stub\r\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\r\n  *\r\n  * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n  * @param  {Message.Message}                           busPostMessage     configuration\r\n  * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n  */\r\n  constructor() {\r\n    console.log('[AbstractIdpProxy] constructor');\r\n  }\r\n\r\n  _init(runtimeProtoStubURL, bus, config) {\r\n    let _this = this;\r\n    _this.runtimeProtoStubURL = runtimeProtoStubURL;\r\n    _this.messageBus = bus;\r\n    _this.config = config;\r\n    IdpProxy = config.idpProxy;\r\n    convertUserProfile = config.convertUserProfile;\r\n    accessTokenInput = config.accessTokenInput;\r\n\r\n\r\n\r\n    _this.messageBus.addListener('*', function (msg) {\r\n      if (msg.to === config.idpUrl) {\r\n\r\n        _this.requestToIdp(msg);\r\n      }\r\n    });\r\n    _this._sendStatus('created');\r\n  }\r\n\r\n  /**\r\n  * Function that see the intended method in the message received and call the respective function\r\n  *\r\n  * @param {message}  message received in the messageBus\r\n  */\r\n  requestToIdp(msg) {\r\n    let _this = this;\r\n    let params = msg.body.params;\r\n    //console.info('requestToIdp:', msg.body.method);\r\n    console.info('[AbstractIdpProxyProtoStub] receiving request: ', msg);\r\n\r\n    switch (msg.body.method) {\r\n      case 'generateAssertion':\r\n        IdpProxy.generateAssertion(_this.config, params.contents, params.origin, params.usernameHint).then(\r\n          function (value) {\r\n\r\n            value.userProfile = convertUserProfile(value.userProfile);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'validateAssertion':\r\n        //       console.info('validateAssertion');\r\n        IdpProxy.validateAssertion(_this.config, params.assertion, params.origin).then(\r\n          function (value) { _this.replyMessage(msg, value); },\r\n\r\n          function (error) { _this.replyMessage(msg, error); }\r\n        );\r\n        break;\r\n      case 'refreshAssertion':\r\n        //     console.info('refreshAssertion');\r\n        IdpProxy.refreshAssertion(params.identity).then(\r\n          function (value) { _this.replyMessage(msg, value); },\r\n\r\n          function (error) { _this.replyMessage(msg, error, value, 401); }\r\n        );\r\n        break;\r\n      case 'getAccessTokenAuthorisationEndpoint':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.getAccessTokenAuthorisationEndpoint(_this.config, params.resources).then(\r\n          function (value) {\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'getAccessToken':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.getAccessToken(_this.config, params.resources, params.login).then(\r\n          function (value) {\r\n            console.info('OIDC.getAccessToken result: ', value);\r\n            value.input = accessTokenInput(value.input);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'refreshAccessToken':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.refreshAccessToken(_this.config, params.token).then(\r\n          function (value) {\r\n            console.info('OIDC.refreshAccessToken result: ', value);\r\n//            value.input = accessTokenInput(value.input);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      case 'revokeAccessToken':\r\n        //     console.info('getAccessToken');\r\n        IdpProxy.revokeAccessToken(_this.config, params.token).then(\r\n          function (value) {\r\n            console.info('OIDC.revokeAccessToken result: ', value);\r\n//            value.input = accessTokenInput(value.input);\r\n            _this.replyMessage(msg, value);\r\n          },\r\n\r\n          function (error) { _this.replyMessage(msg, error, 401); }\r\n        );\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function receives a message and a value. It replies the value to the sender of the message received\r\n  *\r\n  * @param  {message}   message received\r\n  * @param  {value}     value to include in the new message to send\r\n  */\r\n  replyMessage(msg, value, code = 200) {\r\n    let _this = this;\r\n\r\n    let message = {\r\n      id: msg.id, type: 'response', to: msg.from, from: msg.to,\r\n      body: { code: code }\r\n    };\r\n\r\n    if (code < 300 ) message.body.value = value;\r\n    else message.body.description = value;\r\n\r\n    console.log('[AbstractIdpProxyProtoStub.replyMessage] ', message);\r\n\r\n    _this.messageBus.postMessage(message);\r\n  }\r\n\r\n  _sendStatus(value, reason) {\r\n    let _this = this;\r\n\r\n    console.log('[AbstractIdpProxyProtoStub.sendStatus] ', value);\r\n\r\n    _this._state = value;\r\n\r\n    let msg = {\r\n      type: 'update',\r\n      from: _this.runtimeProtoStubURL,\r\n      to: _this.runtimeProtoStubURL + '/status',\r\n      body: {\r\n        value: value\r\n      }\r\n    };\r\n\r\n    if (reason) {\r\n      msg.body.desc = reason;\r\n    }\r\n\r\n    _this.messageBus.postMessage(msg);\r\n  }\r\n}\r\n\r\n// export default IdpProxyProtoStub;\r\n\r\n/**\r\n * To activate this protocol stub, using the same method for all protostub.\r\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n * @param  {Message.Message}                           busPostMessage     configuration\r\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n * @return {Object} Object with name and instance of ProtoStub\r\n */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AbstractIdpProxyProtoStub);\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/AbstractIdpProxyStub.js?");

/***/ }),

/***/ "./src/idpproxy/OIDC.js":
/*!******************************!*\
  !*** ./src/idpproxy/OIDC.js ***!
  \******************************/
/*! exports provided: getExpiresAtJSON, getExpires, IdpProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getExpiresAtJSON\", function() { return getExpiresAtJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getExpires\", function() { return getExpires; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IdpProxy\", function() { return IdpProxy; });\n// import {getExpires} from './OAUTH';\r\n\r\nlet identities = {};\r\nlet nIdentity = 0;\r\nlet redirectURI = location.protocol + '//' + location.hostname + (location.port !== '' ? ':' + location.port : '');\r\n\r\n\r\n//let tokenEndpoint;\r\n//let authorisationEndpoint;\r\nlet accessTokenEndpoint;\r\nlet refreshAccessTokenEndpoint;\r\nlet domain;\r\nlet accessTokenAuthorisationEndpoint;\r\nlet revokeAccessTokenEndpoint;\r\n\r\nlet getExpiresAtJSON = (function (json) {\r\n  let expires = json.hasOwnProperty('expires_in') ? json.expires_in : false\r\n\r\n  if (expires) expires = expires + Math.floor(Date.now() / 1000);\r\n  else expires = 3153600000 + Math.floor(Date.now() / 1000);\r\n\r\n  return Number(expires);\r\n\r\n});\r\n\r\nlet getExpires = (function (url) {\r\n  let expires = urlParser(url, 'expires_in');\r\n\r\n  if (expires) expires = expires + Math.floor(Date.now() / 1000);\r\n  else expires = 3153600000 + Math.floor(Date.now() / 1000);\r\n\r\n  return Number(expires);\r\n\r\n});\r\n\r\n//function to parse the query string in the given URL to obatin certain values\r\nfunction urlParser(url, name) {\r\n  name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\r\n  let regexS = '[\\\\#&?]' + name + '=([^&#]*)';\r\n  let regex = new RegExp(regexS);\r\n  let results = regex.exec(url);\r\n  if (results === null)\r\n    return false;\r\n  else\r\n    return results[1];\r\n}\r\n\r\nfunction sendHTTPRequest(method, url) {\r\n  let xhr = new XMLHttpRequest();\r\n  if ('withCredentials' in xhr) {\r\n    xhr.open(method, url, true);\r\n  } else if (typeof XDomainRequest != 'undefined') {\r\n    // Otherwise, check if XDomainRequest.\r\n    // XDomainRequest only exists in IE, and is IE's way of making CORS requests.\r\n    xhr = new XDomainRequest();\r\n    xhr.open(method, url);\r\n  } else {\r\n    // Otherwise, CORS is not supported by the browser.\r\n    xhr = null;\r\n  }\r\n  return new Promise(function (resolve, reject) {\r\n    if (xhr) {\r\n      xhr.onreadystatechange = function (e) {\r\n        if (xhr.readyState === 4) {\r\n          if (xhr.status === 200) {\r\n            let info = JSON.parse(xhr.responseText);\r\n            resolve(info);\r\n          } else if (xhr.status === 400) {\r\n            reject('There was an error processing the token');\r\n          } else {\r\n            reject('something else other than 200 was returned');\r\n          }\r\n        }\r\n      };\r\n      xhr.send();\r\n    } else {\r\n      reject('CORS not supported');\r\n    }\r\n  });\r\n}\r\n\r\nlet getAccessTokenWithCodeToken = (function (resources, url) {\r\n  return new Promise(function (resolve, reject) {\r\n    let code = urlParser(url, 'code');\r\n\r\n    if (!code) reject('[OIDC.getAccessTokenWithCodeToken] code not include in the url: ', url);\r\n\r\n    sendHTTPRequest('POST', accessTokenEndpoint(code)).then(function (info) {\r\n\r\n      console.info('[OIDC.getAccessTokenWithCodeToken] response: ', info);\r\n\r\n      if (info.hasOwnProperty('access_token')) {\r\n\r\n        let expires = getExpiresAtJSON(info);\r\n        let refresh = info.hasOwnProperty('refresh_token') ? info.refresh_token : false;\r\n        resolve(accessTokenResult(resources, info.access_token, expires, info, refresh));\r\n      } else reject('[OIDC.getAccessTokenWithCodeToken] access token not returned in the exchange code result: ', info);\r\n    }, function (error) {\r\n      reject(error);\r\n    });\r\n\r\n  });\r\n});\r\n\r\nlet accessTokenResult = (function (resources, accessToken, expires, input, refresh) {\r\n\r\n  let result = { domain: domain, resources: resources, accessToken: accessToken, expires: expires, input: input };\r\n\r\n  if (refresh) result.refresh = refresh;\r\n\r\n  return result;\r\n\r\n});\r\n\r\n\r\n/**\r\n* Function to exchange the code received to the id Token, access token and a refresh token\r\n*\r\n*/\r\n/*let exchangeCode = (function(code) {\r\n  let i = googleInfo;\r\n\r\n  let URL = i.tokenEndpoint + 'code=' + code + '&client_id=' + i.clientID + '&client_secret=' + i.clientSecret + '&redirect_uri=' + i.redirectURI + '&grant_type=authorization_code&access_type=' + i.accessType;\r\n\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    sendHTTPRequest('POST', URL).then(function(info) {\r\n      console.log('[OIDC.exchangeCode] returned info: ', info);\r\n      resolve(info);\r\n    }, function(error) {\r\n      reject(error);\r\n    });\r\n\r\n  });\r\n});\r\n\r\nlet exchangeRefreshToken = (function(refreshToken) {\r\n  let i = googleInfo;\r\n\r\n  let URL = i.tokenEndpoint + 'client_id=' + i.clientID + '&client_secret=' + i.clientSecret + '&refresh_token=' + refreshToken + '&grant_type=refresh_token';\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    sendHTTPRequest('POST', URL).then(function(info) {\r\n      resolve(info);\r\n    }, function(error) {\r\n      reject(error);\r\n    });\r\n\r\n  });\r\n});*/\r\n\r\n/**\r\n* Identity Provider Proxy\r\n*/\r\nlet IdpProxy = {\r\n\r\n  /**\r\n  * Function to validate an identity Assertion received\r\n  * TODO add details of the implementation, and improve the implementation\r\n  *\r\n  * @param  {idpInfo}      Object information about IdP endpoints\r\n  * @param  {assertion}    Identity Assertion to be validated\r\n  * @param  {origin}       Origin parameter that identifies the origin of the RTCPeerConnection\r\n  * @return {Promise}      Returns a promise with the identity assertion validation result\r\n  */\r\n  validateAssertion: (config, assertion, origin) => {\r\n    console.info('[OIDC.validateAssertionProxy] assertion: ', atob(assertion))\r\n    //    console.info('validateAssertionProxy:atob(assertion)', atob(assertion));\r\n\r\n    //TODO check the values with the hash received\r\n    //  return new Promise(function(resolve,reject) {\r\n\r\n    let decodedContent2 = atob(assertion);\r\n    let content = JSON.parse(decodedContent2);\r\n    let idTokenSplited = content.tokenID.split('.');\r\n    let idToken = JSON.parse(atob(idTokenSplited[1]));\r\n\r\n    //resolve({identity: idToken.email, contents: idToken.nonce});\r\n\r\n    //});\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      let i = config.idpInfo;\r\n      let decodedContent = atob(assertion);\r\n      let content = JSON.parse(decodedContent);\r\n      sendHTTPRequest('GET', i.tokenInfo + content.tokenID).then(result => {\r\n        if (JSON.stringify(result) === JSON.stringify(content.tokenIDJSON)) {\r\n          resolve({ identity: content.tokenIDJSON.email, contents: content.tokenIDJSON });\r\n        } else {\r\n          reject('invalid');\r\n        }\r\n      }).catch(err => {\r\n        reject(err);\r\n      });\r\n    });\r\n  },\r\n\r\n  refreshAssertion: (identity) => {\r\n    console.log('OIDC.refreshAssertion:oldIdentity', identity);\r\n    //    let i = googleInfo;\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      /*      if (identity.info.refreshToken) {\r\n              exchangeRefreshToken(identity.info.refreshToken).then(function(value) {\r\n                let infoTokenURL = i.userinfo + value.access_token;\r\n                sendHTTPRequest('GET', infoTokenURL).then(function(infoToken) {\r\n      \r\n                  let identityBundle = {accessToken: value.access_token, idToken: value.id_token, refreshToken: identity.info.refreshToken, tokenType: identity.info.tokenType, infoToken: infoToken};\r\n                  let idTokenURL = i.tokenInfo + value.id_token;\r\n      \r\n                  //obtain information about the user idToken\r\n                  sendHTTPRequest('GET', idTokenURL).then(function(idToken) {\r\n      \r\n                    identityBundle.tokenIDJSON = idToken;\r\n                    identityBundle.expires = idToken.exp;\r\n                    identityBundle.email = idToken.email;\r\n      \r\n                    let oldIDToken = JSON.parse(atob(identity.assertion));\r\n                    let oldIdTokenSplited = oldIDToken.tokenID.split('.');\r\n                    let oldDecodedIDToken = JSON.parse(atob(oldIdTokenSplited[1]));\r\n                    let idNonce = oldDecodedIDToken.nonce;\r\n      \r\n                    let receivedIDToken = value.id_token;\r\n                    let idTokenSplited = receivedIDToken.split('.');\r\n                    let decodedIDToken = JSON.parse(atob(idTokenSplited[1]));\r\n      \r\n                    decodedIDToken.nonce = idNonce;\r\n                    let insertedNonce = btoa(JSON.stringify(decodedIDToken));\r\n                    let newIDToken = idTokenSplited[0] + '.' +\r\n                                       insertedNonce + '.' +\r\n                                       idTokenSplited[2];\r\n      \r\n                    let assertion = btoa(JSON.stringify({tokenID: newIDToken, tokenIDJSON: idToken}));\r\n                    let idpBundle = {domain: 'google.com', protocol: 'OIDC'};\r\n      \r\n                    //TODO delete later the field infoToken, and delete the need in the example\r\n                    let returnValue = {assertion: assertion, idp: idpBundle, info: identityBundle, infoToken: infoToken};\r\n                    //console.log('PROXY:refreshAssertion:newIdentity', returnValue);\r\n                    resolve(returnValue);\r\n                  });\r\n                });\r\n              });\r\n            }*/\r\n      resolve(identity);\r\n    });\r\n\r\n\r\n  },\r\n\r\n  /**\r\n  * Function to generate an identity Assertion\r\n  * TODO add details of the implementation, and improve implementation\r\n  *\r\n  * @param  {idpInfo}      Object information about IdP endpoints\r\n  * @param  {contents} The contents includes information about the identity received\r\n  * @param  {origin} Origin parameter that identifies the origin of the RTCPeerConnection\r\n  * @param  {usernameHint} optional usernameHint parameter\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n  generateAssertion: (config, contents, origin, hint) => {\r\n    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OIDC.generateAssertion:hint]', hint);\r\n    let i = config.idpInfo;\r\n\r\n    //start the login phase\r\n    //TODO later should be defined a better approach\r\n    return new Promise(function (resolve, reject) {\r\n      if (!hint) {\r\n        /*try {\r\n          if (window) {\r\n            resolve('url');\r\n          }\r\n        } catch (error) {*/\r\n\r\n        let requestUrl = i.authorisationEndpoint + 'redirect_uri=' + redirectURI\r\n          + '&prompt=consent&response_type=' + i.type\r\n          + '&client_id=' + i.clientID\r\n          + '&scope=' + i.scope\r\n          + '&access_type=' + i.accessType\r\n          + '&nonce=' + contents\r\n          + '&state=' + i.state;\r\n\r\n        //        let requestUrl = i.authorisationEndpoint + 'scope=' + i.scope + '&client_id=' + i.clientID + '&redirect_uri=' + i.redirectURI + '&response_type=code' + /*i.type +*/ '&state=' + i.state + '&prompt=consent&access_type=' + i.accessType + '&nonce=' + contents;\r\n        console.log('[OIDC.generateAssertion] NO_HINT: rejecting with requestUrl ', requestUrl);\r\n\r\n        reject({ name: 'IdPLoginError', loginUrl: requestUrl });\r\n\r\n        //  }\r\n\r\n      } else {\r\n        // the request have already been made, so idpPRoxy will exchange the tokens along to the idp, to obtain the information necessary\r\n        let accessToken = urlParser(hint, 'access_token');\r\n        let idToken = urlParser(hint, 'id_token');\r\n        let code = urlParser(hint, 'code');\r\n\r\n        //console.log('GOOGLE_PROXY_HINT: ', hint);\r\n\r\n        //       exchangeCode(code).then(function(value) {\r\n        //       console.log('[OIDC.generateAssertion] obtained exchanged Token ', value);\r\n\r\n        //obtain information about the user\r\n        //let infoTokenURL = i.userinfo + value.access_token;\r\n        let infoTokenURL = i.userinfo + accessToken;\r\n        sendHTTPRequest('GET', infoTokenURL).then(function (infoToken) {\r\n          console.log('[OIDC.generateAssertion] obtained infoToken ', infoToken);\r\n\r\n          //            let identityBundle = {accessToken: value.access_token, idToken: value.id_token, refreshToken: value.refresh_token, tokenType: value.token_type, infoToken: infoToken};\r\n\r\n          //            let idTokenURL = i.tokenInfo + value.id_token;\r\n          /*\r\n                      let identityBundle = {\r\n                        accessToken: accessToken,\r\n                        idToken: idToken,\r\n          //              refreshToken: value.refresh_token,\r\n                        tokenType: 'Bearer',\r\n                        infoToken: infoToken\r\n                      };*/\r\n\r\n          let idTokenURL = i.tokenInfo + idToken;\r\n\r\n          //obtain information about the user idToken\r\n          sendHTTPRequest('GET', idTokenURL).then(function (idTokenJSON) {\r\n            console.log('[OIDC.generateAssertion] obtained idToken ', idTokenJSON);\r\n\r\n            /*              identityBundle.tokenIDJSON = idTokenJSON;\r\n                          identityBundle.expires = idTokenJSON.exp;\r\n                          identityBundle.email = idTokenJSON.email;*/\r\n\r\n            let assertion = btoa(JSON.stringify({ tokenID: idToken, tokenIDJSON: idTokenJSON }));\r\n            let idpBundle = { domain: i.domain, protocol: 'OIDC' };\r\n\r\n            //TODO delete later the field infoToken, and delete the need in the example\r\n            // TODO replace \"refresh: true\" by the real refresh token\r\n            let returnValue = { assertion: assertion, idp: idpBundle, expires: idTokenJSON.exp, userProfile: infoToken, refresh: true };\r\n\r\n            identities[nIdentity] = returnValue;\r\n            ++nIdentity;\r\n\r\n            console.log('[OIDC.generateAssertion] returning: ', JSON.stringify(returnValue));\r\n\r\n            resolve(returnValue);\r\n          }, function (e) {\r\n\r\n            reject(e);\r\n          });\r\n        }, function (error) {\r\n\r\n          reject(error);\r\n        });\r\n        /*        }, function(err) {\r\n        \r\n                  reject(err);\r\n                });*/\r\n\r\n      }\r\n    });\r\n  },\r\n\r\n  /**\r\n  * Function to get an Access Token endpoint\r\n  *\r\n  * @param  {config}      Object information about IdP endpoints\r\n  * @param  {resources} Object contents includes information about the identity received\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n\r\n  getAccessTokenAuthorisationEndpoint: (config, resources) => {\r\n    console.log('[OIDC.getAccessTokenAuthorisationEndpoint:config]', config);\r\n    //    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    //    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OIDC.getAccessTokenAuthorisationEndpoint:resources]', resources);\r\n    //    let i = idpInfo;\r\n    accessTokenAuthorisationEndpoint = config.accessTokenAuthorisationEndpoint;\r\n    const mapping = config.mapping;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // TODO replace by resources[0]\r\n      resolve(accessTokenAuthorisationEndpoint(mapping(resources)));\r\n\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n\r\n  /**\r\n  * Function to get an Access Token\r\n  *\r\n  * @param  {login} optional login result\r\n  * @return {Promise} returns a promise with an identity assertion\r\n  */\r\n\r\n  getAccessToken: (config, resources, login) => {\r\n    console.log('[OIDC.getAccessToken:config]', config);\r\n    //    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    //    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OIDC.getAccessToken:login]', login);\r\n    //    let i = idpInfo;\r\n    accessTokenEndpoint = config.accessTokenEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // the user is loggedin, try to extract the Access Token and its expires\r\n      let expires = getExpires(login);\r\n\r\n      let accessToken = urlParser(login, 'access_token');\r\n\r\n      if (accessToken) resolve(accessTokenResult(resources, accessToken, expires, login));\r\n      else resolve(getAccessTokenWithCodeToken(resources, login));\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n\r\n  /**\r\n    * Function to refresh an Access Token\r\n    *\r\n    * @param  {login} optional login result\r\n    * @return {Promise} returns a promise with an identity assertion\r\n    */\r\n\r\n  refreshAccessToken: (config, token) => {\r\n    console.log('[OIDC.refreshAccessToken:config]', config);\r\n    //    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    //    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OIDC.refreshAccessToken:outdated token]', token);\r\n    //    let i = idpInfo;\r\n    refreshAccessTokenEndpoint = config.refreshAccessTokenEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // the user is loggedin, try to extract the Access Token and its expires\r\n\r\n      let refresh = token.refresh;\r\n\r\n      if (!refresh) reject('[OIDC.refreshAccessToken] refresh token not available in the access token', token);\r\n\r\n      sendHTTPRequest('POST', refreshAccessTokenEndpoint(refresh)).then(function (info) {\r\n\r\n        console.info('[OIDC.refreshAccessToken] response: ', info);\r\n\r\n        if (info.hasOwnProperty('access_token')) {\r\n\r\n          let expires = getExpiresAtJSON(info);\r\n          resolve(accessTokenResult(token.resources, info.access_token, expires, info, refresh));\r\n        } else reject('[OIDC.refreshAccessToken] new access token not returned in the response: ', info);\r\n      }, function (error) {\r\n        reject(error);\r\n      });\r\n\r\n      //      });\r\n\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  },\r\n  /**\r\n    * Function to remove an Access Token\r\n    *\r\n    * @param  {login} optional login result\r\n    * @return {Promise} returns a promise with an identity assertion\r\n    */\r\n\r\n  revokeAccessToken: (config, token) => {\r\n    console.log('[OIDC.revokeAccessToken:config]', config);\r\n    //    console.log('[OIDC.generateAssertion:contents]', contents);\r\n    //    console.log('[OIDC.generateAssertion:origin]', origin);\r\n    console.log('[OIDC.revokeAccessToken: token]', token);\r\n    //    let i = idpInfo;\r\n    revokeAccessTokenEndpoint = config.revokeAccessTokenEndpoint;\r\n    domain = config.domain;\r\n\r\n    let _this = undefined;\r\n    //start the login phase\r\n    return new Promise(function (resolve, reject) {\r\n      // the user is loggedin, try to extract the Access Token and its expires\r\n\r\n      let refresh = token.refresh;\r\n\r\n      if (!refresh) reject('[OIDC.revokeAccessToken] refresh token not available in the access token', token);\r\n\r\n      sendHTTPRequest('POST', revokeAccessTokenEndpoint(token.accessToken)).then(function (info) {\r\n\r\n        console.info('[OIDC.revokeAccessToken] response: ', info);\r\n\r\n        resolve(true);\r\n      }, function (error) {\r\n        reject(error);\r\n      });\r\n\r\n      //      });\r\n\r\n    }, function (e) {\r\n\r\n      reject(e);\r\n    });\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/OIDC.js?");

/***/ }),

/***/ "./src/idpproxy/google/GoogleConverter.js":
/*!************************************************!*\
  !*** ./src/idpproxy/google/GoogleConverter.js ***!
  \************************************************/
/*! exports provided: convertUserProfile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertUserProfile\", function() { return convertUserProfile; });\n\r\n// function to convert google user profile info into standard reTHINK user profile object\r\n\r\nfunction convertUserProfile(googleUserProfile) {\r\n\r\n  googleUserProfile.userURL = 'user://google.com/' + googleUserProfile.email;\r\n\r\n  if (!googleUserProfile.hasOwnProperty('preferred_username')) \r\n    googleUserProfile.preferred_username = googleUserProfile.email.split('@')[0];\r\n\r\n  return googleUserProfile;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/google/GoogleConverter.js?");

/***/ }),

/***/ "./src/idpproxy/google/GoogleInfo.js":
/*!*******************************************!*\
  !*** ./src/idpproxy/google/GoogleInfo.js ***!
  \*******************************************/
/*! exports provided: googleInfo, googleAPIInfo, accessTokenEndpoint, refreshAccessTokenEndpoint, revokeAccessTokenEndpoint, mapping, accessTokenAuthorisationEndpoint, authorisationEndpoint, accessTokenInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"googleInfo\", function() { return googleInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"googleAPIInfo\", function() { return googleAPIInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"accessTokenEndpoint\", function() { return accessTokenEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"refreshAccessTokenEndpoint\", function() { return refreshAccessTokenEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"revokeAccessTokenEndpoint\", function() { return revokeAccessTokenEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapping\", function() { return mapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"accessTokenAuthorisationEndpoint\", function() { return accessTokenAuthorisationEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authorisationEndpoint\", function() { return authorisationEndpoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"accessTokenInput\", function() { return accessTokenInput; });\n/*\r\n\tSo that an application can use Google's OAuth 2.0 authentication system for user login,\r\n\tfirst is required to set up a project in the Google Developers Console to obtain OAuth 2.0 credentials and set a redirect URI.\r\n\tA test account was created to set the project in the Google Developers Console to obtain OAuth 2.0 credentials,\twith the following credentials:\r\n      \tusername: openidtest10@gmail.com\r\n        password: testOpenID10\r\n\tTo add more URI's, follow the steps:\r\n\t1º choose the project ( can be the My OpenID Project)\t from  https://console.developers.google.com/projectselector/apis/credentials using the credentials provided above.\r\n\t2º Open The Client Web 1 listed in OAuth 2.0 Client ID's\r\n\t3º Add the URI  in the authorized redirect URI section.\r\n  4º change the REDIRECT parameter bellow with the pretended URI\r\n */\r\nlet redirectURI = location.protocol + '//' + location.hostname + (location.port !== '' ? ':' + location.port : '');\r\n\r\nlet googleInfo = {\r\n  \"clientID\": \"808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com\",\r\n  \"issuer\": \"https://accounts.google.com\",\r\n  \"tokenEndpoint\": \"https://www.googleapis.com/oauth2/v4/token?\",\r\n  \"jwksUri\": \"https://www.googleapis.com/oauth2/v3/certs?\",\r\n  \"authorisationEndpoint\": \"https://accounts.google.com/o/oauth2/auth?\",\r\n  \"userinfo\": \"https://www.googleapis.com/oauth2/v3/userinfo?access_token=\",\r\n  \"tokenInfo\": \"https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=\",\r\n  \"accessType\": \"online\",\r\n  \"type\": \"token id_token\",\r\n  \"scope\": \"openid%20email%20profile\",\r\n  \"state\": \"state\",\r\n  \"domain\": \"google.com\"\r\n};\r\n\r\n\r\nlet googleAPIInfo = {\r\n  \"clientID\": \"808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com\",\r\n  \"issuer\": \"https://accounts.google.com\",\r\n  \"tokenEndpoint\": \"https://www.googleapis.com/oauth2/v4/token?\",\r\n  \"revokeEndpoint\": \"https://accounts.google.com/o/oauth2/revoke?\",\r\n  \"jwksUri\": \"https://www.googleapis.com/oauth2/v3/certs?\",\r\n  \"authorisationEndpoint\": \"https://accounts.google.com/o/oauth2/auth?\",\r\n  \"userinfo\": \"https://www.googleapis.com/oauth2/v3/userinfo?access_token=\",\r\n  \"tokenInfo\": \"https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=\",\r\n  \"accessType\": \"offline\",\r\n  \"type\": \"code\",\r\n  // TODO - scope is read from message (support multiple Google APIs)\r\n  \"scope\": \"https://www.googleapis.com/auth/fitness.location.read\",\r\n  \"state\": \"state\",\r\n  \"domain\": \"google.com\",\r\n  'grant_type': \"authorization_code\",\r\n  'secret': \"Xx4rKucb5ZYTaXlcZX9HLfZW\"\r\n};\r\n\r\n\r\n\r\nfunction accessTokenEndpoint(code) {\r\n\r\n  return googleAPIInfo.tokenEndpoint\r\n    + 'client_id=' + googleAPIInfo.clientID\r\n    + '&code=' + code\r\n    + '&grant_type=authorization_code'\r\n    + '&access_type=' + 'offline'\r\n    + '&client_secret=' + googleAPIInfo.secret\r\n    + '&redirect_uri=' + redirectURI;\r\n}\r\n\r\nfunction refreshAccessTokenEndpoint(refresh) {\r\n\r\n  return googleAPIInfo.tokenEndpoint\r\n    + 'client_id=' + googleAPIInfo.clientID\r\n    + '&refresh_token=' + refresh\r\n    + '&grant_type=refresh_token'\r\n    + '&client_secret=' + googleAPIInfo.secret\r\n}\r\n\r\nfunction revokeAccessTokenEndpoint(token) {\r\n\r\n  return googleAPIInfo.revokeEndpoint\r\n    + '&token=' + token\r\n}\r\n\r\nfunction mapping(resource) {\r\n  if (!resource) {\r\n    return \"fitness.location.read%20https://www.googleapis.com/auth/fitness.activity.read\";\r\n  }\r\n  switch (resource) {\r\n    case \"user_activity_context\":\r\n      return \"fitness.location.read%20https://www.googleapis.com/auth/fitness.activity.read\";\r\n      break;\r\n\r\n    default:\r\n      return \"fitness.location.read%20https://www.googleapis.com/auth/fitness.activity.read\";\r\n      break;\r\n  }\r\n}\r\n\r\nfunction accessTokenAuthorisationEndpoint(API) {\r\n  let url = googleAPIInfo.authorisationEndpoint\r\n    + 'redirect_uri=' + redirectURI\r\n    + '&response_type=' + googleAPIInfo.type\r\n    + '&client_id=' + googleAPIInfo.clientID\r\n    + '&scope=' + 'https://www.googleapis.com/auth/' + API\r\n    + '&access_type=' + googleAPIInfo.accessType\r\n//    + '&include_granted_scopes=true'\r\n//    + '&prompt=none'\r\n    + '&state=' + googleAPIInfo.state;\r\n  console.log('[GoogleInfo.accessTokenAuthorisationEndpoint] ', url);\r\n  return url;\r\n}\r\n\r\nfunction authorisationEndpoint(nonce) {\r\n\r\n  let url = googleAPIInfo.authorisationEndpoint\r\n    + 'redirect_uri=' + redirectURI\r\n    + '&response_type=' + googleAPIInfo.type\r\n    + '&client_id=' + googleAPIInfo.clientID\r\n    + '&scope=' + googleAPIInfo.scope\r\n    + '&access_type=' + googleAPIInfo.accessType\r\n    + '&state=' + nonce;\r\n  console.log('[GoogleInfo.authorisationEndpoint] ', url);\r\n  return url;\r\n}\r\n\r\nfunction accessTokenInput(info) {\r\n\r\n  return {info};\r\n}\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/google/GoogleInfo.js?");

/***/ }),

/***/ "./src/idpproxy/google/google.com.idp.js":
/*!***********************************************!*\
  !*** ./src/idpproxy/google/google.com.idp.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GoogleIdpProxyProtoStub; });\n/* harmony import */ var _OIDC_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../OIDC.js */ \"./src/idpproxy/OIDC.js\");\n/* harmony import */ var _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoogleInfo.js */ \"./src/idpproxy/google/GoogleInfo.js\");\n/* harmony import */ var _GoogleConverter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GoogleConverter.js */ \"./src/idpproxy/google/GoogleConverter.js\");\n/* harmony import */ var _AbstractIdpProxyStub_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../AbstractIdpProxyStub.js */ \"./src/idpproxy/AbstractIdpProxyStub.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n* Google Identity Provider Proxy Protocol Stub\r\n*/\r\nclass GoogleIdpProxyProtoStub extends _AbstractIdpProxyStub_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n\r\n  /**\r\n  * Constructor of the IdpProxy Stub\r\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\r\n  *\r\n  * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n  * @param  {Message.Message}                           busPostMessage     configuration\r\n  * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n  */\r\n constructor() {\r\n  super();\r\n\r\n }\r\n  _start(runtimeProtoStubURL, bus, config) {\r\n    console.log('[GoogleIdpProxyProtoStub._start] ');\r\n    config.domain = 'google.com';\r\n    config.idpUrl = 'domain-idp://google.com';\r\n    config.idpProxy = _OIDC_js__WEBPACK_IMPORTED_MODULE_0__[\"IdpProxy\"];\r\n    config.idpInfo = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"googleInfo\"];\r\n    config.apiInfo = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"googleAPIInfo\"];\r\n    config.accessTokenAuthorisationEndpoint = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"accessTokenAuthorisationEndpoint\"];\r\n    config.accessTokenEndpoint = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"accessTokenEndpoint\"];\r\n    config.refreshAccessTokenEndpoint = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"refreshAccessTokenEndpoint\"];\r\n    config.revokeAccessTokenEndpoint = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"revokeAccessTokenEndpoint\"];\r\n    config.accessTokenInput = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"accessTokenInput\"];\r\n    config.authorisationEndpoint = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"authorisationEndpoint\"];\r\n    config.convertUserProfile = _GoogleConverter_js__WEBPACK_IMPORTED_MODULE_2__[\"convertUserProfile\"];\r\n    config.mapping = _GoogleInfo_js__WEBPACK_IMPORTED_MODULE_1__[\"mapping\"];\r\n    super._init(runtimeProtoStubURL, bus, config);\r\n  }\r\n\r\n}\r\n\r\n// export default IdpProxyProtoStub;\r\n\r\n/**\r\n * To activate this protocol stub, using the same method for all protostub.\r\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\r\n * @param  {Message.Message}                           busPostMessage     configuration\r\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\r\n * @return {Object} Object with name and instance of ProtoStub\r\n */\r\n//export default GoogleIdpProxyProtoStub;\r\n\r\n/*  export default function activate(url, bus, config) {\r\n  return {\r\n    name: 'GoogleIdpProxyProtoStub',\r\n    instance: new GoogleIdpProxyProtoStub(url, bus, config)\r\n  };\r\n}*/\r\n\n\n//# sourceURL=webpack:///./src/idpproxy/google/google.com.idp.js?");

/***/ })

/******/ })
			);
		}
	};
});