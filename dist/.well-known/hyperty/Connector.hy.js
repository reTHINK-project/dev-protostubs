System.register([], function(__WEBPACK_DYNAMIC_EXPORT__) {

	return {

		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/hyperty/connector/Connector.hy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/hyperty/connector/ConnectionController.js":
/*!*******************************************************!*\
  !*** ./src/hyperty/connector/ConnectionController.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connection */ \"./src/hyperty/connector/connection.js\");\n/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/* jshint undef: true */\r\n/* globals RTCPeerConnection */\r\n/* globals RTCSessionDescription */\r\n/* globals RTCIceCandidate */\r\n\r\n\r\n\r\n\r\n\r\nclass ConnectionController {\r\n\r\n  constructor(syncher, domain, configuration, clean, connector, remoteHyperty) {\r\n\r\n    if (!syncher) throw new Error('The syncher is a needed parameter');\r\n    if (!domain) throw new Error('The domain is a needed parameter');\r\n    if (!configuration) throw new Error('The configuration is a needed parameter');\r\n\r\n    let _this = this;\r\n\r\n    _this.mode = 'offer';\r\n    _this._connector = connector;\r\n    _this._remoteHyperty = remoteHyperty;\r\n\r\n    // Private\r\n    _this._syncher = syncher;\r\n    _this._configuration = configuration;\r\n    _this._domain = domain;\r\n    _this._objectDescURL = 'hyperty-catalogue://catalogue.' + _this._domain + '/.well-known/dataschema/Connection';\r\n    _this._clean = clean;\r\n\r\n    // Prepare the PeerConnection\r\n    let peerConnection = new RTCPeerConnection(_this._configuration);\r\n\r\n    peerConnection.addEventListener('signalingstatechange', function(event) {\r\n\r\n      console.info('[Connector.ConnectionController ]signalingstatechange', event.currentTarget.signalingState);\r\n\r\n      if (event.currentTarget.signalingState === 'have-local-offer') {\r\n        console.info('[Connector.ConnectionController ]signalingstatechange - have-local-offer: ', event.currentTarget.signalingState);\r\n      }\r\n\r\n      if (event.currentTarget.signalingState === 'have-remote-offer') {\r\n        console.info('[Connector.ConnectionController ]signalingstatechange - have-remote-offer: ', event.currentTarget.signalingState);\r\n        _this.mode = 'answer';\r\n      }\r\n\r\n    });\r\n\r\n    peerConnection.addEventListener('iceconnectionstatechange', function(event) {\r\n      console.info('[Connector.ConnectionController ]iceconnectionstatechange', event.currentTarget.iceConnectionState, _this.dataObjectReporter);\r\n      let data = _this.dataObjectReporter.data;\r\n      if (data.hasOwnProperty('status')) {\r\n        data.status = event.currentTarget.iceConnectionState;\r\n      }\r\n    });\r\n\r\n    peerConnection.addEventListener('icecandidate', function(event) {\r\n\r\n      console.info('[Connector.ConnectionController ]icecandidate changes', event.candidate, _this.dataObjectReporter);\r\n\r\n      if (!event.candidate) return;\r\n\r\n      let icecandidate = {\r\n        type: 'candidate',\r\n        candidate: event.candidate.candidate,\r\n        sdpMid: event.candidate.sdpMid,\r\n        sdpMLineIndex: event.candidate.sdpMLineIndex\r\n      };\r\n\r\n      let data = _this.dataObjectReporter.data;\r\n      let ices = JSON.parse(JSON.stringify(data.iceCandidates));\r\n\r\n      console.log('[Connector.ConnectionController] - push iceCandidates: ', data, data.iceCandidates);\r\n\r\n      // new model\r\n      ices.push(icecandidate);\r\n\r\n      /*\r\n\r\n      if (_this.mode === 'offer') {\r\n        data.ownerPeer.iceCandidates.push(icecandidate);\r\n      } else {\r\n        data.Peer.iceCandidates.push(icecandidate);\r\n      }*/\r\n      _this.dataObjectReporter.data.iceCandidates = ices;\r\n    });\r\n\r\n    // Add stream to PeerConnection\r\n    peerConnection.addEventListener('addstream', function(event) {\r\n      console.info('[Connector.ConnectionController ]Add Stream: ', event);\r\n\r\n      if (_this._onAddStream) _this._onAddStream(event);\r\n    });\r\n\r\n    peerConnection.onremovestream = function(event) {\r\n      console.info('[Connector.ConnectionController ]Stream removed: ', event);\r\n    };\r\n\r\n    _this.peerConnection = peerConnection;\r\n\r\n  }\r\n\r\n  set mediaStream(mediaStream) {\r\n    if (!mediaStream) throw new Error('The mediaStream is a needed parameter');\r\n\r\n    let _this = this;\r\n    console.info('[Connector.ConnectionController ]set stream: ', mediaStream);\r\n    _this._mediaStream = mediaStream;\r\n    _this.peerConnection.addStream(mediaStream);\r\n  }\r\n\r\n  get mediaStream() {\r\n    let _this = this;\r\n    return _this._mediaStream;\r\n  }\r\n\r\n  /**\r\n  * Set the dataObject in the controller\r\n  * @param {ConnectionDataObject} dataObject - have all information about the syncher object;\r\n  */\r\n  set dataObjectReporter(dataObjectReporter) {\r\n    if (!dataObjectReporter) throw new Error('The Data Object Reporter is a needed parameter');\r\n\r\n    let _this = this;\r\n    console.info('[Connector.ConnectionController ]set data object reporter: ', dataObjectReporter);\r\n    _this._dataObjectReporter = dataObjectReporter;\r\n\r\n    dataObjectReporter.onSubscription(function(event) {\r\n      if (event.type === 'subscribe') event.accept();\r\n      else {//to handle reject from remote peer\r\n        _this._removeMediaStream();\r\n        if (_this._onDisconnect) _this._onDisconnect(event);\r\n        _this._clean(_this._connector._controllers, _this._remoteHyperty);\r\n      }\r\n    });\r\n\r\n    if (_this.mode === 'offer') {\r\n      _this._createOffer();\r\n    } else {\r\n      _this._createAnswer();\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n  * return the dataObject in the controller\r\n  * @return {ConnectionDataObject} dataObject\r\n  */\r\n  get dataObjectReporter() {\r\n    let _this = this;\r\n    return _this._dataObjectReporter;\r\n  }\r\n\r\n  /**\r\n  * Set the dataObject in the controller\r\n  * @param {ConnectionDataObject} dataObject - have all information about the syncher object;\r\n  */\r\n  set dataObjectObserver(dataObjectObserver) {\r\n    if (!dataObjectObserver) throw new Error('The Data Object Observer is a needed parameter');\r\n\r\n    let _this = this;\r\n\r\n    console.info('[Connector.ConnectionController ]set data object observer: ', dataObjectObserver);\r\n    _this._dataObjectObserver = dataObjectObserver;\r\n    _this._changePeerInformation(dataObjectObserver);\r\n\r\n  }\r\n\r\n  /**\r\n  * return the dataObject in the controller\r\n  * @return {ConnectionDataObject} dataObject\r\n  */\r\n  get dataObjectObserver() {\r\n    let _this = this;\r\n    return _this._dataObjectObserver;\r\n  }\r\n\r\n  /**\r\n   * Set the connection event to accept or reject\r\n   * @param  {CreateEvent} event Event with actions to accept or reject the connection\r\n   */\r\n  set connectionEvent(event) {\r\n    let _this = this;\r\n    _this._connectionEvent = event;\r\n  }\r\n\r\n  /**\r\n   * Get the connection event to accept or reject\r\n   * @return {CreateEvent}\r\n   */\r\n  get connectionEvent() {\r\n    let _this = this;\r\n    return _this._connectionEvent;\r\n  }\r\n\r\n  set deleteEvent(event) {\r\n    let _this = this;\r\n    _this._deleteEvent = event;\r\n\r\n    _this._removeMediaStream();\r\n    if (_this._onDisconnect) _this._onDisconnect(event);\r\n    _this._clean(_this._connector._controllers, _this._remoteHyperty);\r\n  }\r\n\r\n  get deleteEvent() {\r\n    let _this = this;\r\n    return _this._deleteEvent;\r\n  }\r\n\r\n  _removeMediaStream() {\r\n    let _this = this;\r\n    console.log(_this.mediaStream, _this.peerConnection);\r\n\r\n    if (_this.mediaStream && _this.peerConnection) {\r\n\r\n      let tracks = _this.mediaStream.getTracks();\r\n\r\n      tracks.forEach((track) => {\r\n        track.stop();\r\n      });\r\n    }\r\n\r\n    if (_this.peerConnection) {\r\n      /*_this.peerConnection.removeStream(_this.mediaStream);\r\n      _this.peerConnection.close();*/\r\n      _this.peerConnection = null;\r\n    }\r\n  }\r\n\r\n  _changePeerInformation(dataObjectObserver) {\r\n    let _this = this;\r\n    let data = dataObjectObserver.data;\r\n    let isOwner = data.hasOwnProperty('ownerPeer');\r\n\r\n    // New model\r\n    let peerData = dataObjectObserver.data;\r\n    // let peerData = isOwner ? data.ownerPeer : data.Peer;\r\n\r\n    console.info('[Connector.ConnectionController ]Peer Data:', JSON.stringify(peerData));\r\n\r\n    if (peerData.hasOwnProperty('connectionDescription')) {\r\n      _this._processPeerInformation(peerData.connectionDescription);\r\n    }\r\n\r\n    if (peerData.hasOwnProperty('iceCandidates')) {\r\n\r\n      console.log('Process Peer data: ', peerData);\r\n\r\n      peerData.iceCandidates.forEach(function(ice) {\r\n        _this._processPeerInformation(ice);\r\n      });\r\n    }\r\n\r\n    dataObjectObserver.onChange('*', function(event) {\r\n      console.info('[Connector.ConnectionController ]Observer on change message: ', event);\r\n      _this._processPeerInformation(event.data);\r\n    });\r\n\r\n  }\r\n\r\n  _processPeerInformation(data) {\r\n    let _this = this;\r\n\r\n    console.info('[Connector.ConnectionController processPeerInformation ]', JSON.stringify(data));\r\n\r\n    if (data.type === 'offer' || data.type === 'answer') {\r\n      console.info('[Connector.ConnectionController processPeerInformation]Process Connection Description: ', data.sdp);\r\n      _this.peerConnection.setRemoteDescription(new RTCSessionDescription(data), _this._remoteDescriptionSuccess, _this._remoteDescriptionError);\r\n    }\r\n\r\n    if (data.type === 'candidate') {\r\n      console.info('[Connector.ConnectionController ]Process Ice Candidate: ', data);\r\n      _this.peerConnection.addIceCandidate(new RTCIceCandidate({candidate: data.candidate}), _this._remoteDescriptionSuccess, _this._remoteDescriptionError);\r\n    }\r\n  }\r\n\r\n  _remoteDescriptionSuccess() {\r\n    console.info('[Connector.ConnectionController ]remote success');\r\n  }\r\n\r\n  _remoteDescriptionError(error) {\r\n    console.error('error: ', error);\r\n  }\r\n\r\n  _createOffer() {\r\n    let _this = this;\r\n\r\n    _this.peerConnection.createOffer(function(description) {\r\n      _this._onLocalSessionCreated(description);\r\n    }, _this._infoError);\r\n\r\n  }\r\n\r\n  _createAnswer() {\r\n    let _this = this;\r\n\r\n    _this.peerConnection.createAnswer(function(description) {\r\n      _this._onLocalSessionCreated(description);\r\n    }, _this._infoError);\r\n  }\r\n\r\n  _onLocalSessionCreated(description) {\r\n\r\n    let _this = this;\r\n\r\n    _this.peerConnection.setLocalDescription(description, function() {\r\n\r\n      let data = _this.dataObjectReporter.data;\r\n\r\n      let sdpConnection = {\r\n        sdp: description.sdp,\r\n        type: description.type\r\n      };\r\n\r\n      // new model\r\n      data.connectionDescription = sdpConnection;\r\n\r\n/*      if (_this.mode === 'offer') {\r\n        data.ownerPeer.connectionDescription = sdpConnection;\r\n      } else {\r\n        data.Peer.connectionDescription = sdpConnection;\r\n      }*/\r\n\r\n    }, _this._infoError);\r\n\r\n  }\r\n\r\n  _infoError(err) {\r\n    console.error(err.toString(), err);\r\n  }\r\n\r\n  /**\r\n   * This function is used to receive all changes did to dataObjectObjserver.\r\n   * @param  {Function} callback callback function\r\n   * @return {ChangeEvent}       properties and type of changes;\r\n   */\r\n\r\n  // onChange(callback) {\r\n  //   let _this = this;\r\n  //   _this._onChange = callback;\r\n  // }\r\n\r\n  /**\r\n   * This function is used to handle the peer stream\r\n   * @return {MediaStream}           WebRTC remote MediaStream retrieved by the Application\r\n   */\r\n  onAddStream(callback) {\r\n    let _this = this;\r\n    _this._onAddStream = callback;\r\n  }\r\n\r\n  /**\r\n   * This function is used to receive requests to close an existing connection instance.\r\n   * @param  {Function} callback callback function to handle with the disconnect\r\n   * @return {DeleteEvent}       the DeleteEvent fired by the Syncher when the Connection is closed.\r\n   */\r\n  onDisconnect(callback) {\r\n    let _this = this;\r\n    _this._onDisconnect = callback;\r\n  }\r\n\r\n  /**\r\n   * This function is used to accept an incoming connection request received by connection.onInvitation().\r\n   * @param  {MediaStream}         stream     WebRTC local MediaStream retrieved by the Application\r\n   * @return {<Promise> boolean}              It returns, as a Promise, true in case the connection is successfully accepted, false otherwise.\r\n   */\r\n  accept(stream) {\r\n\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      let syncher = _this._syncher;\r\n      let remoteData = _this.dataObjectObserver.data;\r\n      let remotePeer = remoteData.owner;\r\n\r\n      _this.connectionObject = _connection__WEBPACK_IMPORTED_MODULE_1__[\"connection\"];\r\n      console.log('[ConnectionController - Accept] - Remote Peer Information: ', remoteData);\r\n\r\n      _this.connectionObject.name = remoteData.name;\r\n      _this.connectionObject.scheme = 'connection';\r\n      _this.connectionObject.owner = remoteData.owner;\r\n      _this.connectionObject.peer = remoteData.peer;\r\n      _this.connectionObject.status = '';\r\n\r\n      try {\r\n        console.info('[Connector.ConnectionController ]------------------------ Syncher Create ---------------------- \\n');\r\n\r\n        syncher.create(_this._objectDescURL, [remotePeer], _this.connectionObject, false, false, remoteData.name, {}, {resources: ['audio', 'video']})\r\n        .then(function(dataObjectReporter) {\r\n          console.info('[Connector.ConnectionController ]2. Return the Data Object Reporter ', dataObjectReporter);\r\n\r\n          _this.mediaStream = stream;\r\n          _this.dataObjectReporter = dataObjectReporter;\r\n          resolve(true);\r\n        })\r\n        .catch(function(reason) {\r\n          console.error(reason);\r\n          reject(false);\r\n        });\r\n\r\n      } catch (e) {\r\n        reject('error accepting connection');\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n   * This function is used to decline an incoming connection request received by connection.onInvitation().\r\n   * @param  {int} reason               Integer decline reason that is compliant with RFC7231. If not present 400 is used. (optional)\r\n   * @return {<Promise> boolean}        It returns, as a Promise, true in case the connection is successfully declined, false otherwise.\r\n   */\r\n  decline(reason) {\r\n\r\n    // TODO: Optimize this process\r\n\r\n    let _this = this;\r\n    let declineReason = 400;\r\n    if (reason) declineReason = reason;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      try {\r\n      //  _this.connectionEvent.ack(declineReason);\r\n        _this.disconnect().then(()=>{\r\n          resolve(true);\r\n        });\r\n      } catch (e) {\r\n        console.error(e);\r\n        reject(false);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * This function is used to close an existing connection instance.\r\n   * @return {<Promise> boolean} It returns as a Promise true if successfully disconnected or false otherwise.\r\n   */\r\n  disconnect() {\r\n    // TODO: Optimize this process\r\n\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      try {\r\n\r\n        let data;\r\n        if (_this.dataObjectReporter) {\r\n          data = _this.dataObjectReporter;\r\n          data.delete();\r\n        }\r\n\r\n        if (_this.dataObjectObserver) {\r\n          data = _this.dataObjectObserver;\r\n          data.delete();\r\n        }\r\n\r\n        _this._removeMediaStream();\r\n        _this._clean(_this._connector._controllers, _this._remoteHyperty);\r\n\r\n        resolve(true);\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n   * Disable Microfone\r\n   * @param  {boolean} value status of microfone\r\n   * @return {boolean}\r\n   */\r\n  disableAudio(value) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      try {\r\n        let localStream = _this.peerConnection.getLocalStreams()[0];\r\n        let audioTrack = localStream.getAudioTracks()[0];\r\n\r\n        if (!value) {\r\n          audioTrack.enabled = audioTrack.enabled ? false : true;\r\n        } else {\r\n          audioTrack.enabled = value;\r\n        }\r\n\r\n        resolve(audioTrack.enabled);\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n   * Disable video\r\n   * @param  {boolean} value status of video\r\n   * @return {boolean}\r\n   */\r\n  disableVideo(value) {\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      try {\r\n        let localStream = _this.peerConnection.getLocalStreams()[0];\r\n        let videoTrack = localStream ? localStream.getVideoTracks()[0] : null;\r\n\r\n        if (videoTrack) {\r\n          if (!value) {\r\n            videoTrack.enabled = videoTrack.enabled ? false : true;\r\n          } else {\r\n            videoTrack.enabled = value;\r\n          }\r\n\r\n          resolve(videoTrack.enabled);\r\n        } else {\r\n          reject('not ready yet');\r\n        }\r\n\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  mute(value) {\r\n\r\n    let _this = this;\r\n\r\n    return new Promise(function(resolve, reject) {\r\n\r\n      try {\r\n        let remoteStream = _this.peerConnection.getRemoteStreams()[0];\r\n        let audioTrack = remoteStream.getAudioTracks()[0];\r\n\r\n        if (!value) {\r\n          audioTrack.enabled = audioTrack.enabled ? false : true;\r\n        } else {\r\n          audioTrack.enabled = value;\r\n        }\r\n\r\n        resolve(audioTrack.enabled);\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ConnectionController);\r\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/ConnectionController.js?");

/***/ }),

/***/ "./src/hyperty/connector/Connector.hy.js":
/*!***********************************************!*\
  !*** ./src/hyperty/connector/Connector.hy.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ConnectionController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConnectionController */ \"./src/hyperty/connector/ConnectionController.js\");\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connection */ \"./src/hyperty/connector/connection.js\");\n/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n/* jshint undef: true */\r\n\r\n// Service Framework\r\n//import IdentityManager from 'service-framework/dist/IdentityManager';\r\n//import {Discovery} from 'service-framework/dist/Discovery';\r\n//import {Syncher} from 'service-framework/dist/Syncher';\r\n\r\n// Utils\r\n//import {divideURL} from '../utils/utils';\r\n\r\n// Internals\r\n//import { hypertyDescriptor } from './ConnectorDescriptor';\r\n\r\n\r\n//import AbstractHyperty from '../AbstractHyperty';\r\n\r\n\r\n\r\n/**\r\n *\r\n */\r\nclass Connector  {\r\n\r\n  /**\r\n  * Create a new Hyperty Connector\r\n  */\r\n  constructor() {\r\n//    this.name = 'Connector';\r\n  }\r\n\r\n  set name (val){\r\n    this._name = val;\r\n  }\r\n\r\n  get name(){\r\n    return this._name;\r\n  }\r\n\r\n/*  get descriptor() {\r\n    return hypertyDescriptor;\r\n  }*/\r\n\r\n  get runtimeHypertyURL(){\r\n    return this._hypertyURL;\r\n  }\r\n\r\n  _start(hypertyURL, bus, configuration, factory) {\r\n\r\n    if (!hypertyURL) throw new Error('The hypertyURL is a needed parameter');\r\n    if (!bus) throw new Error('The MiniBus is a needed parameter');\r\n    if (!configuration) throw new Error('The configuration is a needed parameter');\r\n\r\n    let _this = this;\r\n    _this._hypertyURL = hypertyURL;\r\n    _this._bus = bus;\r\n    _this._configuration = configuration;\r\n    _this._domain = factory.divideURL(hypertyURL).domain;\r\n\r\n    _this._objectDescURL = 'hyperty-catalogue://catalogue.' + _this._domain + '/.well-known/dataschema/Connection';\r\n\r\n    _this._controllers = {};\r\n    _this.connectionObject = _connection__WEBPACK_IMPORTED_MODULE_1__[\"connection\"];\r\n\r\n    let discovery = factory.createDiscovery(hypertyURL, configuration.runtimeURL, bus);\r\n    let identityManager = factory.createIdentityManager(hypertyURL, configuration.runtimeURL, bus);\r\n\r\n    _this.discovery = discovery;\r\n    _this.identityManager = identityManager;\r\n\r\n    _this.search = factory.createSearch(discovery, identityManager);\r\n\r\n    console.log('Discover: ', discovery);\r\n    console.log('Identity Manager: ', identityManager);\r\n\r\n    let syncher = factory.createSyncher(hypertyURL, bus, configuration);\r\n\r\n    syncher.onNotification((event) => {\r\n\r\n      let _this = this;\r\n\r\n      console.log('On Notification: ', event);\r\n\r\n      if (event.type === 'create') {\r\n        console.info('------------ Acknowledges the Reporter - Create ------------ \\n');\r\n        event.ack(200);\r\n\r\n        if (_this._controllers[event.from]) {\r\n          _this._autoSubscribe(event);\r\n        } else {\r\n\r\n          _this._autoAccept(event);\r\n        }\r\n\r\n        console.info('------------------------ End Create ---------------------- \\n');\r\n\r\n      }\r\n\r\n      if (event.type === 'delete') {\r\n        console.info('------------ Acknowledges the Reporter - Delete ------------ \\n');\r\n        event.ack(200);\r\n\r\n        console.log(_this._controllers);\r\n        if (_this._controllers) {\r\n          Object.keys(_this._controllers).forEach((controller) => {\r\n            _this._controllers[controller].deleteEvent = event;\r\n            delete _this._controllers[controller];\r\n\r\n            console.log('Controllers:', _this._controllers);\r\n          });\r\n        }\r\n\r\n        console.info('------------------------ End Create ---------------------- \\n');\r\n      }\r\n\r\n    });\r\n\r\n    _this._syncher = syncher;\r\n\r\n    let msgToInit = {\r\n      type: 'init', from: hypertyURL, to: 'sip://test@rethink-project.eu',\r\n      body: { source: hypertyURL, schema: _this._objectDescURL }\r\n    };\r\n\r\n    // bus.postMessage(msgToInit, (reply) => {\r\n    // });\r\n\r\n  }\r\n\r\n  // callback when connection Controllers are disconnected\r\n\r\n  _removeController(controllers, controller) {\r\n    let _this = this;\r\n\r\n    if (controllers) {\r\n      delete controllers[controller];\r\n\r\n      console.log('[Connector] removed controller for ', controller);\r\n    }\r\n  }\r\n\r\n  _autoSubscribe(event) {\r\n    let _this = this;\r\n    let syncher = _this._syncher;\r\n\r\n    console.info('---------------- Syncher Subscribe (Auto Subscribe) ---------------- \\n');\r\n    console.info('Subscribe URL Object ', event);\r\n    let input = {\r\n      schema: _this._objectDescURL,\r\n      resource: event.url\r\n    };\r\n\r\n    syncher.subscribe(input).then(function (dataObjectObserver) {\r\n      console.info('1. Return Subscribe Data Object Observer', dataObjectObserver);\r\n      _this._controllers[event.from].dataObjectObserver = dataObjectObserver;\r\n    }).catch(function (reason) {\r\n      console.error(reason);\r\n    });\r\n  }\r\n\r\n  _autoAccept(event) {\r\n    let _this = this;\r\n    let syncher = _this._syncher;\r\n\r\n    console.info('---------------- Syncher Subscribe (Auto Accept) ---------------- \\n');\r\n    console.info('Subscribe URL Object ', event);\r\n    let input = {\r\n      schema: _this._objectDescURL,\r\n      resource: event.url\r\n    };\r\n\r\n    syncher.subscribe(input).then(function (dataObjectObserver) {\r\n      console.info('1. Return Subscribe Data Object Observer', dataObjectObserver);\r\n\r\n      let connectionController = new _ConnectionController__WEBPACK_IMPORTED_MODULE_0__[\"default\"](syncher, _this._domain, _this._configuration, _this._removeController, _this, event.from);\r\n      connectionController.connectionEvent = event;\r\n      connectionController.dataObjectObserver = dataObjectObserver;\r\n\r\n      if (Object.keys(_this._controllers).length > 0) {      // check if there an ongoing call\r\n        ongoingCall = true;\r\n      }\r\n\r\n      _this._controllers[event.from] = connectionController;\r\n\r\n      let identity = event.identity;\r\n\r\n      let ongoingCall;\r\n\r\n\r\n\r\n\r\n      if (!identity) {\r\n        identity = {};\r\n        identity.userProfile = {\r\n          picture: \"https://www.mybloggerguides.com/wp-content/uploads/2016/01/anonymous_picture.png\",\r\n          name: 'anonymous',\r\n          userURL: 'anonymous',\r\n          preferred_username: \"anonymous\"\r\n        };\r\n      }\r\n\r\n      if (ongoingCall) {\r\n        // ongoing call lets decline we busy\r\n        connectionController.decline(486, 'Busy Here');\r\n      } else if (_this._onInvitation) {\r\n        // TODO: user object with {identity: event.identity, assertedIdentity: assertedIdentity}\r\n        _this._onInvitation(connectionController, identity.userProfile);\r\n      }\r\n\r\n      console.info('------------------------ END ---------------------- \\n');\r\n    }).catch(function (reason) {\r\n      console.error(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This function is used to create a new connection providing the identifier of the user to be notified.\r\n   * @param  {URL.UserURL}        userURL      user to be invited that is identified with reTHINK User URL.\r\n   * @param  {MediaStream}        stream       WebRTC local MediaStream retrieved by the Application\r\n   * @param  {string}             name         is a string to identify the connection.\r\n   * @return {<Promise>ConnectionController}   A ConnectionController object as a Promise.\r\n   */\r\n  connect(userURL, stream, name, domain) {\r\n    // TODO: Pass argument options as a stream, because is specific of implementation;\r\n    // TODO: CHange the hypertyURL for a list of URLS\r\n    let _this = this;\r\n    let syncher = _this._syncher;\r\n    let scheme = ['connection'];\r\n    let resource = ['audio', 'video'];\r\n\r\n    console.log('connecting: ', userURL);\r\n\r\n    return new Promise(function (resolve, reject) {\r\n\r\n      let connectionController;\r\n      let selectedHyperty;\r\n      console.info('------------------------ Syncher Create ----------------------  \\n');\r\n\r\n      _this.search.myIdentity().then(function (identity) {\r\n\r\n        console.log('connector searching: ', [userURL], `at domain `, [domain]);\r\n        console.log('identity: ', identity, _this.connectionObject);\r\n\r\n        return _this.search.users([userURL], [domain], scheme, resource);\r\n      })\r\n        .then(function (hypertiesIDs) {\r\n\r\n          // Only support one to one connection;*/\r\n          selectedHyperty = hypertiesIDs[0].hypertyID;\r\n          console.info('Only support communication one to one, selected hyperty: ', selectedHyperty);\r\n\r\n          let connectionName = 'Connection';\r\n          if (name) {\r\n            connectionName = name;\r\n          }\r\n\r\n          // Initial data\r\n          _this.connectionObject.name = connectionName;\r\n          _this.connectionObject.scheme = 'connection';\r\n          _this.connectionObject.owner = _this._hypertyURL;\r\n          _this.connectionObject.peer = selectedHyperty;\r\n          _this.connectionObject.status = '';\r\n\r\n          return syncher.create(_this._objectDescURL, [selectedHyperty], _this.connectionObject, false, false, name, {}, { resources: ['audio', 'video'] });\r\n        })\r\n        .catch(function (reason) {\r\n          console.error(reason);\r\n          reject(reason);\r\n        })\r\n        .then(function (dataObjectReporter) {\r\n          console.info('1. Return Create Data Object Reporter', dataObjectReporter);\r\n\r\n          connectionController = new _ConnectionController__WEBPACK_IMPORTED_MODULE_0__[\"default\"](syncher, _this._domain, _this._configuration, _this._removeController, _this, selectedHyperty);\r\n          connectionController.mediaStream = stream;\r\n          connectionController.dataObjectReporter = dataObjectReporter;\r\n\r\n          _this._controllers[selectedHyperty] = connectionController;\r\n\r\n          resolve(connectionController);\r\n          console.info('--------------------------- END --------------------------- \\n');\r\n        })\r\n        .catch(function (reason) {\r\n          console.error(reason);\r\n          reject(reason);\r\n        });\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This function is used to handle notifications about incoming requests to create a new connection.\r\n   * @param  {Function} callback\r\n   * @return {event}\r\n   */\r\n  onInvitation(callback) {\r\n    let _this = this;\r\n    _this._onInvitation = callback;\r\n  }\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Connector);\r\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/Connector.hy.js?");

/***/ }),

/***/ "./src/hyperty/connector/connection.js":
/*!*********************************************!*\
  !*** ./src/hyperty/connector/connection.js ***!
  \*********************************************/
/*! exports provided: connection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connection\", function() { return connection; });\n/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the ''License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\r\n\r\n// dataObjectReporter.data = {\r\n//    status : \"connected\",\r\n//    owner : \"hyperty://example.com/alicehy\",\r\n//    peer : \"connection://example.com/alice/bob27012016\",\r\n//    ownerPeer : {\r\n//          connectionDescription: {\r\n//             sdp: 's4dfaf1sa3f1asd5f4sdafa',\r\n//             type: 'offer'\r\n//          },\r\n//          iceCandidates: [{\r\n//              type: 'candidate',\r\n//              candidate: event.candidate.candidate,\r\n//              sdpMid: event.candidate.sdpMid,\r\n//              sdpMLineIndex: event.candidate.sdpMLineIndex\r\n//            },\r\n//            {\r\n//              type: 'candidate',\r\n//              candidate: event.candidate.candidate,\r\n//              sdpMid: event.candidate.sdpMid,\r\n//              sdpMLineIndex: event.candidate.sdpMLineIndex\r\n//            },\r\n//            .....\r\n//        ]\r\n//      }\r\n//  }\r\n\r\nlet connection = {\r\n  name: '',\r\n  scheme: '',\r\n  status: '',\r\n  owner: '',\r\n  connectionDescription: {},\r\n  iceCandidates: []\r\n};\r\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/connection.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/sdp/sdp.js":
/*!*******************************************************!*\
  !*** ./src/hyperty/connector/node_modules/sdp/sdp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" /* eslint-env node */\n\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress); // was: relAddr\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort); // was: relPort\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n}\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  // was: channels\n  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n          ? '/' + headerExtension.direction\n          : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      params.push(param + '=' + codec.parameters[param]);\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n}\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n      'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n          mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  caps.headerExtensions.forEach(function(extension) {\n    sdp += SDPUtils.writeExtmap(extension);\n  });\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n  .map(function(line) {\n    var parts = line.split(' ');\n    parts.shift();\n    return parts.map(function(part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n        rtx: {\n          ssrc: secondarySsrc\n        }\n      };\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: secondarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  var cname;\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n      .map(function(line) {\n        return SDPUtils.parseSsrcMedia(line);\n      })\n      .filter(function(obj) {\n        return obj.attribute === 'cname';\n      })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n}\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/sdp/sdp.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!**********************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\nvar adapterFactory = __webpack_require__(/*! ./adapter_factory.js */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_factory.js\");\nmodule.exports = adapterFactory({window: global.window});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_core.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!*************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\n// Shimming starts here.\nmodule.exports = function(dependencies, opts) {\n  var window = dependencies && dependencies.window;\n\n  var options = {\n    shimChrome: true,\n    shimFirefox: true,\n    shimEdge: true,\n    shimSafari: true,\n  };\n\n  for (var key in opts) {\n    if (hasOwnProperty.call(opts, key)) {\n      options[key] = opts[key];\n    }\n  }\n\n  // Utils.\n  var utils = __webpack_require__(/*! ./utils */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\n  var logging = utils.log;\n  var browserDetails = utils.detectBrowser(window);\n\n  // Export to the adapter global object visible in the browser.\n  var adapter = {\n    browserDetails: browserDetails,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings\n  };\n\n  // Uncomment the line below if you want logging to occur, including logging\n  // for the switch statement below. Can also be turned on in the browser via\n  // adapter.disableLog(false), but then logging from the switch statement below\n  // will not appear.\n  // require('./utils').disableLog(false);\n\n  // Browser shims.\n  var chromeShim = __webpack_require__(/*! ./chrome/chrome_shim */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\") || null;\n  var edgeShim = __webpack_require__(/*! ./edge/edge_shim */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/edge_shim.js\") || null;\n  var firefoxShim = __webpack_require__(/*! ./firefox/firefox_shim */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\") || null;\n  var safariShim = __webpack_require__(/*! ./safari/safari_shim */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/safari/safari_shim.js\") || null;\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n\n      chromeShim.shimGetUserMedia(window);\n      chromeShim.shimMediaStream(window);\n      utils.shimCreateObjectURL(window);\n      chromeShim.shimSourceObject(window);\n      chromeShim.shimPeerConnection(window);\n      chromeShim.shimOnTrack(window);\n      chromeShim.shimAddTrackRemoveTrack(window);\n      chromeShim.shimGetSendersWithDtmf(window);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n\n      firefoxShim.shimGetUserMedia(window);\n      utils.shimCreateObjectURL(window);\n      firefoxShim.shimSourceObject(window);\n      firefoxShim.shimPeerConnection(window);\n      firefoxShim.shimOnTrack(window);\n      break;\n    case 'edge':\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edgeShim;\n\n      edgeShim.shimGetUserMedia(window);\n      utils.shimCreateObjectURL(window);\n      edgeShim.shimPeerConnection(window);\n      edgeShim.shimReplaceTrack(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n      // shim window.URL.createObjectURL Safari (technical preview)\n      utils.shimCreateObjectURL(window);\n      safariShim.shimRTCIceServerUrls(window);\n      safariShim.shimCallbacksAPI(window);\n      safariShim.shimLocalStreamsAPI(window);\n      safariShim.shimRemoteStreamsAPI(window);\n      safariShim.shimGetUserMedia(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/adapter_factory.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!****************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\nvar utils = __webpack_require__(/*! ../utils.js */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\nvar chromeShim = {\n  shimMediaStream: function(window) {\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\n  },\n\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n          }\n          this.addEventListener('track', this._ontrack = f);\n        }\n      });\n      var origSetRemoteDescription =\n          window.RTCPeerConnection.prototype.setRemoteDescription;\n      window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n        var pc = this;\n        if (!pc._ontrackpoly) {\n          pc._ontrackpoly = function(e) {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', function(te) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === te.track.id;\n                });\n              } else {\n                receiver = {track: te.track};\n              }\n\n              var event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(function(track) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === track.id;\n                });\n              } else {\n                receiver = {track: track};\n              }\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n          };\n          pc.addEventListener('addstream', pc._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n    }\n  },\n\n  shimGetSendersWithDtmf: function(window) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\n      var shimSenderWithDtmf = function(pc, track) {\n        return {\n          track: track,\n          get dtmf() {\n            if (this._dtmf === undefined) {\n              if (track.kind === 'audio') {\n                this._dtmf = pc.createDTMFSender(track);\n              } else {\n                this._dtmf = null;\n              }\n            }\n            return this._dtmf;\n          },\n          _pc: pc\n        };\n      };\n\n      // augment addTrack when getSenders is not available.\n      if (!window.RTCPeerConnection.prototype.getSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function() {\n          this._senders = this._senders || [];\n          return this._senders.slice(); // return a copy of the internal state.\n        };\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n          var pc = this;\n          var sender = origAddTrack.apply(pc, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(pc, track);\n            pc._senders.push(sender);\n          }\n          return sender;\n        };\n\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n        window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n          var pc = this;\n          origRemoveTrack.apply(pc, arguments);\n          var idx = pc._senders.indexOf(sender);\n          if (idx !== -1) {\n            pc._senders.splice(idx, 1);\n          }\n        };\n      }\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origAddStream.apply(pc, [stream]);\n        stream.getTracks().forEach(function(track) {\n          pc._senders.push(shimSenderWithDtmf(pc, track));\n        });\n      };\n\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\n\n        stream.getTracks().forEach(function(track) {\n          var sender = pc._senders.find(function(s) {\n            return s.track === track;\n          });\n          if (sender) {\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\n          }\n        });\n      };\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\n               'getSenders' in window.RTCPeerConnection.prototype &&\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\n               window.RTCRtpSender &&\n               !('dtmf' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function(sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = this._pc.createDTMFSender(this.track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function(window) {\n    var URL = window && window.URL;\n\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this._srcObject;\n          },\n          set: function(stream) {\n            var self = this;\n            // Use _srcObject as a private property for this shim\n            this._srcObject = stream;\n            if (this.src) {\n              URL.revokeObjectURL(this.src);\n            }\n\n            if (!stream) {\n              this.src = '';\n              return undefined;\n            }\n            this.src = URL.createObjectURL(stream);\n            // We need to recreate the blob url when a track is added or\n            // removed. Doing it manually since we want to avoid a recursion.\n            stream.addEventListener('addtrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n            stream.addEventListener('removetrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n          }\n        });\n      }\n    }\n  },\n\n  shimAddTrackRemoveTrack: function(window) {\n    // shim addTrack and removeTrack.\n    if (window.RTCPeerConnection.prototype.addTrack) {\n      return;\n    }\n\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\n        .getLocalStreams;\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var self = this;\n      var nativeStreams = origGetLocalStreams.apply(this);\n      self._reverseStreams = self._reverseStreams || {};\n      return nativeStreams.map(function(stream) {\n        return self._reverseStreams[stream.id];\n      });\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      // Add identity mapping for consistency with addTrack.\n      // Unless this is being used with a stream from addTrack.\n      if (!pc._reverseStreams[stream.id]) {\n        var newStream = new window.MediaStream(stream.getTracks());\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        stream = newStream;\n      }\n      origAddStream.apply(pc, [stream]);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\n          pc._streams[stream.id].id : stream.id)];\n      delete pc._streams[stream.id];\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      var streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(function(t) {\n            return t === track;\n          })) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      var alreadyExists = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n      var oldStream = pc._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n        pc.dispatchEvent(new Event('negotiationneeded'));\n      } else {\n        var newStream = new window.MediaStream([track]);\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        pc.addStream(newStream);\n      }\n      return pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n    };\n\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      var isLocal = sender._pc === pc;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      pc._streams = pc._streams || {};\n      var stream;\n      Object.keys(pc._streams).forEach(function(streamid) {\n        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {\n          return sender.track === track;\n        });\n        if (hasTrack) {\n          stream = pc._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          pc.removeStream(stream);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        pc.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        // Translate iceTransportPolicy to iceTransports,\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\n        logging('PeerConnection');\n        if (pcConfig && pcConfig.iceTransportPolicy) {\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n        }\n\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.webkitRTCPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      if (window.webkitRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.webkitRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n    } else {\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n      var OrigPeerConnection = window.RTCPeerConnection;\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n          var newIceServers = [];\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\n            var server = pcConfig.iceServers[i];\n            if (!server.hasOwnProperty('urls') &&\n                server.hasOwnProperty('url')) {\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n              server = JSON.parse(JSON.stringify(server));\n              server.urls = server.url;\n              newIceServers.push(server);\n            } else {\n              newIceServers.push(pcConfig.iceServers[i]);\n            }\n          }\n          pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(selector,\n        successCallback, errorCallback) {\n      var self = this;\n      var args = arguments;\n\n      // If selector is a function then we are in the old style stats so just\n      // pass back the original getStats format to avoid breaking old users.\n      if (arguments.length > 0 && typeof selector === 'function') {\n        return origGetStats.apply(this, arguments);\n      }\n\n      // When spec-style getStats is supported, return those when called with\n      // either no arguments or the selector argument is null.\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\n          typeof arguments[0] !== 'function')) {\n        return origGetStats.apply(this, []);\n      }\n\n      var fixChromeStats_ = function(response) {\n        var standardReport = {};\n        var reports = response.result();\n        reports.forEach(function(report) {\n          var standardStats = {\n            id: report.id,\n            timestamp: report.timestamp,\n            type: {\n              localcandidate: 'local-candidate',\n              remotecandidate: 'remote-candidate'\n            }[report.type] || report.type\n          };\n          report.names().forEach(function(name) {\n            standardStats[name] = report.stat(name);\n          });\n          standardReport[standardStats.id] = standardStats;\n        });\n\n        return standardReport;\n      };\n\n      // shim getStats with maplike support\n      var makeMapStats = function(stats) {\n        return new Map(Object.keys(stats).map(function(key) {\n          return [key, stats[key]];\n        }));\n      };\n\n      if (arguments.length >= 2) {\n        var successCallbackWrapper_ = function(response) {\n          args[1](makeMapStats(fixChromeStats_(response)));\n        };\n\n        return origGetStats.apply(this, [successCallbackWrapper_,\n          arguments[0]]);\n      }\n\n      // promise-support\n      return new Promise(function(resolve, reject) {\n        origGetStats.apply(self, [\n          function(response) {\n            resolve(makeMapStats(fixChromeStats_(response)));\n          }, reject]);\n      }).then(successCallback, errorCallback);\n    };\n\n    // add promise support -- natively available in Chrome 51\n    if (browserDetails.version < 51) {\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n          .forEach(function(method) {\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\n            window.RTCPeerConnection.prototype[method] = function() {\n              var args = arguments;\n              var self = this;\n              var promise = new Promise(function(resolve, reject) {\n                nativeMethod.apply(self, [args[0], resolve, reject]);\n              });\n              if (args.length < 2) {\n                return promise;\n              }\n              return promise.then(function() {\n                args[1].apply(null, []);\n              },\n              function(err) {\n                if (args.length >= 3) {\n                  args[2].apply(null, [err]);\n                }\n              });\n            };\n          });\n    }\n\n    // promise support for createOffer and createAnswer. Available (without\n    // bugs) since M52: crbug/619289\n    if (browserDetails.version < 52) {\n      ['createOffer', 'createAnswer'].forEach(function(method) {\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function() {\n          var self = this;\n          if (arguments.length < 1 || (arguments.length === 1 &&\n              typeof arguments[0] === 'object')) {\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\n            return new Promise(function(resolve, reject) {\n              nativeMethod.apply(self, [resolve, reject, opts]);\n            });\n          }\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n    }\n\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  }\n};\n\n\n// Expose public methods.\nmodule.exports = {\n  shimMediaStream: chromeShim.shimMediaStream,\n  shimOnTrack: chromeShim.shimOnTrack,\n  shimAddTrackRemoveTrack: chromeShim.shimAddTrackRemoveTrack,\n  shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,\n  shimSourceObject: chromeShim.shimSourceObject,\n  shimPeerConnection: chromeShim.shimPeerConnection,\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\")\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*****************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\nvar utils = __webpack_require__(/*! ../utils.js */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n\n  var constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    var cc = {};\n    Object.keys(c).forEach(function(key) {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      var oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        var oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(function(mix) {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  var shimConstraints_ = function(constraints, func) {\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      var remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      var face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      var getSupportedFacingModeLies = browserDetails.version < 61;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        var matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(function(devices) {\n            devices = devices.filter(function(d) {\n              return d.kind === 'videoinput';\n            });\n            var dev = devices.find(function(d) {\n              return matches.some(function(match) {\n                return d.label.toLowerCase().indexOf(match) !== -1;\n              });\n            });\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        InvalidStateError: 'NotReadableError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotReadableError',\n        MediaDeviceKillSwitchOn: 'NotReadableError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraintName,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, function(c) {\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\n        onError(shimError_(e));\n      });\n    });\n  };\n\n  navigator.getUserMedia = getUserMedia_;\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      navigator.getUserMedia(constraints, resolve, reject);\n    });\n  };\n\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {\n      getUserMedia: getUserMediaPromise_,\n      enumerateDevices: function() {\n        return new Promise(function(resolve) {\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\n          return window.MediaStreamTrack.getSources(function(devices) {\n            resolve(devices.map(function(device) {\n              return {label: device.label,\n                kind: kinds[device.kind],\n                deviceId: device.id,\n                groupId: ''};\n            }));\n          });\n        });\n      },\n      getSupportedConstraints: function() {\n        return {\n          deviceId: true, echoCancellation: true, facingMode: true,\n          frameRate: true, height: true, width: true\n        };\n      }\n    };\n  }\n\n  // A shim for getUserMedia method on the mediaDevices object.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (!navigator.mediaDevices.getUserMedia) {\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      return getUserMediaPromise_(constraints);\n    };\n  } else {\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, function(c) {\n        return origGetUserMedia(c).then(function(stream) {\n          if (c.audio && !stream.getAudioTracks().length ||\n              c.video && !stream.getVideoTracks().length) {\n            stream.getTracks().forEach(function(track) {\n              track.stop();\n            });\n            throw new DOMException('', 'NotFoundError');\n          }\n          return stream;\n        }, function(e) {\n          return Promise.reject(shimError_(e));\n        });\n      });\n    };\n  }\n\n  // Dummy devicechange event methods.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n    navigator.mediaDevices.addEventListener = function() {\n      logging('Dummy mediaDevices.addEventListener called.');\n    };\n  }\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n    navigator.mediaDevices.removeEventListener = function() {\n      logging('Dummy mediaDevices.removeEventListener called.');\n    };\n  }\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/edge_shim.js":
/*!************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/edge_shim.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\nvar shimRTCPeerConnection = __webpack_require__(/*! ./rtcpeerconnection_shim */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/rtcpeerconnection_shim.js\");\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/getusermedia.js\"),\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (window.RTCIceGatherer) {\n      // ORTC defines an RTCIceCandidate object but no constructor.\n      // Not implemented in Edge.\n      if (!window.RTCIceCandidate) {\n        window.RTCIceCandidate = function(args) {\n          return args;\n        };\n      }\n      // ORTC does not have a session description object but\n      // other browsers (i.e. Chrome) that will support both PC and ORTC\n      // in the future might have this defined already.\n      if (!window.RTCSessionDescription) {\n        window.RTCSessionDescription = function(args) {\n          return args;\n        };\n      }\n      // this adds an additional event listener to MediaStrackTrack that signals\n      // when a tracks enabled property was changed. Workaround for a bug in\n      // addStream, see below. No longer required in 15025+\n      if (browserDetails.version < 15025) {\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\n            window.MediaStreamTrack.prototype, 'enabled');\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n          set: function(value) {\n            origMSTEnabled.set.call(this, value);\n            var ev = new Event('enabled');\n            ev.enabled = value;\n            this.dispatchEvent(ev);\n          }\n        });\n      }\n    }\n\n    // ORTC defines the DTMF sender a bit different.\n    // https://github.com/w3c/ortc/issues/714\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = new window.RTCDtmfSender(this);\n            } else if (this.track.kind === 'video') {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n\n    window.RTCPeerConnection =\n        shimRTCPeerConnection(window, browserDetails.version);\n  },\n  shimReplaceTrack: function(window) {\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n    if (window.RTCRtpSender &&\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\n      window.RTCRtpSender.prototype.replaceTrack =\n          window.RTCRtpSender.prototype.setTrack;\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/edge_shim.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/getusermedia.js":
/*!***************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/getusermedia.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var navigator = window && window.navigator;\n\n  var shimError_ = function(e) {\n    return {\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(c) {\n    return origGetUserMedia(c).catch(function(e) {\n      return Promise.reject(shimError_(e));\n    });\n  };\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/getusermedia.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/rtcpeerconnection_shim.js":
/*!*************************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/rtcpeerconnection_shim.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./src/hyperty/connector/node_modules/sdp/sdp.js\");\n\n// sort tracks such that they follow an a-v-a-v...\n// pattern.\nfunction sortTracks(tracks) {\n  var audioTracks = tracks.filter(function(track) {\n    return track.kind === 'audio';\n  });\n  var videoTracks = tracks.filter(function(track) {\n    return track.kind === 'video';\n  });\n  tracks = [];\n  while (audioTracks.length || videoTracks.length) {\n    if (audioTracks.length) {\n      tracks.push(audioTracks.shift());\n    }\n    if (videoTracks.length) {\n      tracks.push(videoTracks.shift());\n    }\n  }\n  return tracks;\n}\n\n// Edge does not like\n// 1) stun:\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n    return false;\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  var RTCPeerConnection = function(config) {\n    var self = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          self[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.needNegotiation = false;\n\n    this.onicecandidate = null;\n    this.onaddstream = null;\n    this.ontrack = null;\n    this.onremovestream = null;\n    this.onsignalingstatechange = null;\n    this.oniceconnectionstatechange = null;\n    this.onicegatheringstatechange = null;\n    this.onnegotiationneeded = null;\n    this.ondatachannel = null;\n    this.canTrickleIceCandidates = null;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n    this.getLocalStreams = function() {\n      return self.localStreams;\n    };\n    this.getRemoteStreams = function() {\n      return self.remoteStreams;\n    };\n\n    this.localDescription = new window.RTCSessionDescription({\n      type: '',\n      sdp: ''\n    });\n    this.remoteDescription = new window.RTCSessionDescription({\n      type: '',\n      sdp: ''\n    });\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    this.iceOptions = {\n      gatherPolicy: 'all',\n      iceServers: []\n    };\n    if (config && config.iceTransportPolicy) {\n      switch (config.iceTransportPolicy) {\n        case 'all':\n        case 'relay':\n          this.iceOptions.gatherPolicy = config.iceTransportPolicy;\n          break;\n        default:\n          // don't set iceTransportPolicy.\n          break;\n      }\n    }\n    this.usingBundle = config && config.bundlePolicy === 'max-bundle';\n\n    if (config && config.iceServers) {\n      this.iceOptions.iceServers = filterIceServers(config.iceServers,\n          edgeVersion);\n    }\n    this._config = config || {};\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    // since the iceGatherer is currently created in createOffer but we\n    // must not emit candidates until after setLocalDescription we buffer\n    // them in this array.\n    this._localIceCandidatesBuffer = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this.dispatchEvent(event);\n    if (this.onicegatheringstatechange !== null) {\n      this.onicegatheringstatechange(event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitBufferedCandidates = function() {\n    var self = this;\n    var sections = SDPUtils.splitSections(self.localDescription.sdp);\n    // FIXME: need to apply ice candidates in a way which is async but\n    // in-order\n    this._localIceCandidatesBuffer.forEach(function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      if (end) {\n        for (var j = 1; j < sections.length; j++) {\n          if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) {\n            sections[j] += 'a=end-of-candidates\\r\\n';\n          }\n        }\n      } else {\n        sections[event.candidate.sdpMLineIndex + 1] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      }\n      self.localDescription.sdp = sections.join('');\n      self.dispatchEvent(event);\n      if (self.onicecandidate !== null) {\n        self.onicecandidate(event);\n      }\n      if (!event.candidate && self.iceGatheringState !== 'complete') {\n        var complete = self.transceivers.every(function(transceiver) {\n          return transceiver.iceGatherer &&\n              transceiver.iceGatherer.state === 'completed';\n        });\n        if (complete && self.iceGatheringStateChange !== 'complete') {\n          self.iceGatheringState = 'complete';\n          self._emitGatheringStateChange();\n        }\n      }\n    });\n    this._localIceCandidatesBuffer = [];\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  // internal helper to create a transceiver object.\n  // (whih is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    this.transceivers.push(transceiver);\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n\n    this._maybeFireNegotiationNeeded();\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var self = this;\n    if (edgeVersion >= 15025) {\n      this.localStreams.push(stream);\n      stream.getTracks().forEach(function(track) {\n        self.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        self.addTrack(track, clonedStream);\n      });\n      this.localStreams.push(clonedStream);\n    }\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var idx = this.localStreams.indexOf(stream);\n    if (idx > -1) {\n      this.localStreams.splice(idx, 1);\n      this._maybeFireNegotiationNeeded();\n    }\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n  // Create ICE gatherer and hook it up.\n  RTCPeerConnection.prototype._createIceGatherer = function(mid,\n      sdpMLineIndex) {\n    var self = this;\n    var iceGatherer = new window.RTCIceGatherer(self.iceOptions);\n    iceGatherer.onlocalcandidate = function(evt) {\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      var end = !cand || Object.keys(cand).length === 0;\n      // Edge emits an empty object for RTCIceCandidateComplete‥\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === undefined) {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        event.candidate.candidate = SDPUtils.writeCandidate(cand);\n      }\n\n      // update local description.\n      var sections = SDPUtils.splitSections(self.localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex + 1] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex + 1] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      self.localDescription.sdp = sections.join('');\n      var transceivers = self._pendingOffer ? self._pendingOffer :\n          self.transceivers;\n      var complete = transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      // Emit candidate if localDescription is set.\n      // Also emits null candidate when all gatherers are complete.\n      switch (self.iceGatheringState) {\n        case 'new':\n          if (!end) {\n            self._localIceCandidatesBuffer.push(event);\n          }\n          if (end && complete) {\n            self._localIceCandidatesBuffer.push(\n                new Event('icecandidate'));\n          }\n          break;\n        case 'gathering':\n          self._emitBufferedCandidates();\n          if (!end) {\n            self.dispatchEvent(event);\n            if (self.onicecandidate !== null) {\n              self.onicecandidate(event);\n            }\n          }\n          if (complete) {\n            self.dispatchEvent(new Event('icecandidate'));\n            if (self.onicecandidate !== null) {\n              self.onicecandidate(new Event('icecandidate'));\n            }\n            self.iceGatheringState = 'complete';\n            self._emitGatheringStateChange();\n          }\n          break;\n        case 'complete':\n          // should not happen... currently!\n          break;\n        default: // no-op.\n          break;\n      }\n    };\n    return iceGatherer;\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var self = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      self._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      self._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      self._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      params.encodings = transceiver.recvEncodingParameters;\n      params.rtcp = {\n        cname: transceiver.rtcpParameters.cname,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var self = this;\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, this.signalingState)) {\n      var e = new Error('Can not set local ' + description.type +\n          ' in state ' + this.signalingState);\n      e.name = 'InvalidStateError';\n      if (arguments.length > 2 && typeof arguments[2] === 'function') {\n        window.setTimeout(arguments[2], 0, e);\n      }\n      return Promise.reject(e);\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // FIXME: What was the purpose of this empty if statement?\n      // if (!this._pendingOffer) {\n      // } else {\n      if (this._pendingOffer) {\n        // VERY limited support for SDP munging. Limited to:\n        // * changing the order of codecs\n        sections = SDPUtils.splitSections(description.sdp);\n        sessionpart = sections.shift();\n        sections.forEach(function(mediaSection, sdpMLineIndex) {\n          var caps = SDPUtils.parseRtpParameters(mediaSection);\n          self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\n        });\n        this.transceivers = this._pendingOffer;\n        delete this._pendingOffer;\n      }\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(self.remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = self.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        var rejected = SDPUtils.isRejected(mediaSection);\n\n        if (!rejected && !transceiver.isDatachannel) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!self.usingBundle || sdpMLineIndex === 0) {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                isIceLite ? 'controlling' : 'controlled');\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          self._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    this.localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    switch (description.type) {\n      case 'offer':\n        this._updateSignalingState('have-local-offer');\n        break;\n      case 'answer':\n        this._updateSignalingState('stable');\n        break;\n      default:\n        throw new TypeError('unsupported type \"' + description.type +\n            '\"');\n    }\n\n    // If a success callback was provided, emit ICE candidates after it\n    // has been executed. Otherwise, emit callback after the Promise is\n    // resolved.\n    var hasCallback = arguments.length > 1 &&\n      typeof arguments[1] === 'function';\n    if (hasCallback) {\n      var cb = arguments[1];\n      window.setTimeout(function() {\n        cb();\n        if (self.iceGatheringState === 'new') {\n          self.iceGatheringState = 'gathering';\n          self._emitGatheringStateChange();\n        }\n        self._emitBufferedCandidates();\n      }, 0);\n    }\n    var p = Promise.resolve();\n    p.then(function() {\n      if (!hasCallback) {\n        if (self.iceGatheringState === 'new') {\n          self.iceGatheringState = 'gathering';\n          self._emitGatheringStateChange();\n        }\n        // Usually candidates will be emitted earlier.\n        window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\n      }\n    });\n    return p;\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var self = this;\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, this.signalingState)) {\n      var e = new Error('Can not set remote ' + description.type +\n          ' in state ' + this.signalingState);\n      e.name = 'InvalidStateError';\n      if (arguments.length > 2 && typeof arguments[2] === 'function') {\n        window.setTimeout(arguments[2], 0, e);\n      }\n      return Promise.reject(e);\n    }\n\n    var streams = {};\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    this.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      this.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      this.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      var rejected = SDPUtils.isRejected(mediaSection);\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (kind === 'application' && protocol === 'DTLS/SCTP') {\n        self.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          isDatachannel: true\n        };\n        return;\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === '1' || cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          self.transceivers[sdpMLineIndex]) {\n        self._disposeIceAndDtlsTransports(sdpMLineIndex);\n        self.transceivers[sdpMLineIndex].iceGatherer =\n            self.transceivers[0].iceGatherer;\n        self.transceivers[sdpMLineIndex].iceTransport =\n            self.transceivers[0].iceTransport;\n        self.transceivers[sdpMLineIndex].dtlsTransport =\n            self.transceivers[0].dtlsTransport;\n        if (self.transceivers[sdpMLineIndex].rtpSender) {\n          self.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              self.transceivers[0].dtlsTransport);\n        }\n        if (self.transceivers[sdpMLineIndex].rtpReceiver) {\n          self.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              self.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = self.transceivers[sdpMLineIndex] ||\n            self._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = usingBundle && sdpMLineIndex > 0 ?\n              self.transceivers[0].iceGatherer :\n              self._createIceGatherer(mid, sdpMLineIndex);\n        }\n\n        if (isComplete && cands.length &&\n            (!usingBundle || sdpMLineIndex === 0)) {\n          transceiver.iceTransport.setRemoteCandidates(cands);\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport,\n              kind);\n\n          track = rtpReceiver.track;\n          // FIXME: does not work with Plan B.\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n              Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                get: function() {\n                  return remoteMsid.stream;\n                }\n              });\n            }\n            Object.defineProperty(track, 'id', {\n              get: function() {\n                return remoteMsid.track;\n              }\n            });\n            streams[remoteMsid.stream].addTrack(track);\n            receiverList.push([track, rtpReceiver,\n              streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            streams.default.addTrack(track);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        self._transceive(self.transceivers[sdpMLineIndex],\n            false,\n            direction === 'sendrecv' || direction === 'sendonly');\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = self.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        self.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        self.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if ((isIceLite || isComplete) && cands.length) {\n            iceTransport.setRemoteCandidates(cands);\n          }\n          iceTransport.start(iceGatherer, remoteIceParameters,\n              'controlling');\n          dtlsTransport.start(remoteDtlsParameters);\n        }\n\n        self._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            streams[remoteMsid.stream].addTrack(track);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            streams.default.addTrack(track);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    this.remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    switch (description.type) {\n      case 'offer':\n        this._updateSignalingState('have-remote-offer');\n        break;\n      case 'answer':\n        this._updateSignalingState('stable');\n        break;\n      default:\n        throw new TypeError('unsupported type \"' + description.type +\n            '\"');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        self.remoteStreams.push(stream);\n        var event = new Event('addstream');\n        event.stream = stream;\n        self.dispatchEvent(event);\n        if (self.onaddstream !== null) {\n          window.setTimeout(function() {\n            self.onaddstream(event);\n          }, 0);\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          var trackEvent = new Event('track');\n          trackEvent.track = track;\n          trackEvent.receiver = receiver;\n          trackEvent.streams = [stream];\n          self.dispatchEvent(trackEvent);\n          if (self.ontrack !== null) {\n            window.setTimeout(function() {\n              self.ontrack(trackEvent);\n            }, 0);\n          }\n        });\n      }\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(self && self.transceivers)) {\n        return;\n      }\n      self.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    if (arguments.length > 1 && typeof arguments[1] === 'function') {\n      window.setTimeout(arguments[1], 0);\n    }\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this.dispatchEvent(event);\n    if (this.onsignalingstatechange !== null) {\n      this.onsignalingstatechange(event);\n    }\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var self = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (self.needNegotiation === false) {\n        return;\n      }\n      self.needNegotiation = false;\n      var event = new Event('negotiationneeded');\n      self.dispatchEvent(event);\n      if (self.onnegotiationneeded !== null) {\n        self.onnegotiationneeded(event);\n      }\n    }, 0);\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var self = this;\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0 || states.checking > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0 || states.completed > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== self.iceConnectionState) {\n      self.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this.dispatchEvent(event);\n      if (this.oniceconnectionstatechange !== null) {\n        this.oniceconnectionstatechange(event);\n      }\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var self = this;\n    if (this._pendingOffer) {\n      throw new Error('createOffer called while there is a pending offer.');\n    }\n    var offerOptions;\n    if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n      offerOptions = arguments[0];\n    } else if (arguments.length === 3) {\n      offerOptions = arguments[2];\n    }\n\n    var numAudioTracks = this.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = this.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        this._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        this._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n    // reorder tracks\n    var transceivers = sortTracks(this.transceivers);\n\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);\n    transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = self.usingBundle && sdpMLineIndex > 0 ?\n            transceivers[0].iceGatherer :\n            self._createIceGatherer(mid, sdpMLineIndex);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video') {\n          sendEncodingParameters[0].rtx = {\n            ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n          transceiver.dtlsTransport,\n          kind\n        );\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (this._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += SDPUtils.writeMediaSection(transceiver,\n          transceiver.localCapabilities, 'offer', transceiver.stream);\n      sdp += 'a=rtcp-rsize\\r\\n';\n    });\n\n    this._pendingOffer = transceivers;\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    if (arguments.length && typeof arguments[0] === 'function') {\n      window.setTimeout(arguments[0], 0, desc);\n    }\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);\n    if (this.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (transceiver.isDatachannel) {\n        sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' +\n            'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video') {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    if (arguments.length && typeof arguments[0] === 'function') {\n      window.setTimeout(arguments[0], 0, desc);\n    }\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    if (!candidate) {\n      for (var j = 0; j < this.transceivers.length; j++) {\n        this.transceivers[j].iceTransport.addRemoteCandidate({});\n        if (this.usingBundle) {\n          return Promise.resolve();\n        }\n      }\n    } else {\n      var mLineIndex = candidate.sdpMLineIndex;\n      if (candidate.sdpMid) {\n        for (var i = 0; i < this.transceivers.length; i++) {\n          if (this.transceivers[i].mid === candidate.sdpMid) {\n            mLineIndex = i;\n            break;\n          }\n        }\n      }\n      var transceiver = this.transceivers[mLineIndex];\n      if (transceiver) {\n        var cand = Object.keys(candidate.candidate).length > 0 ?\n            SDPUtils.parseCandidate(candidate.candidate) : {};\n        // Ignore Chrome's invalid candidates since Edge does not like them.\n        if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n          return Promise.resolve();\n        }\n        // Ignore RTCP candidates, we assume RTCP-MUX.\n        if (cand.component &&\n            !(cand.component === '1' || cand.component === 1)) {\n          return Promise.resolve();\n        }\n        transceiver.iceTransport.addRemoteCandidate(cand);\n\n        // update the remoteDescription.\n        var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\n        sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()\n            : 'a=end-of-candidates') + '\\r\\n';\n        this.remoteDescription.sdp = sections.join('');\n      }\n    }\n    if (arguments.length > 1 && typeof arguments[1] === 'function') {\n      window.setTimeout(arguments[1], 0);\n    }\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.getStats = function() {\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n        'dtlsTransport'].forEach(function(method) {\n          if (transceiver[method]) {\n            promises.push(transceiver[method].getStats());\n          }\n        });\n    });\n    var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&\n        arguments[1];\n    var fixStatsType = function(stat) {\n      return {\n        inboundrtp: 'inbound-rtp',\n        outboundrtp: 'outbound-rtp',\n        candidatepair: 'candidate-pair',\n        localcandidate: 'local-candidate',\n        remotecandidate: 'remote-candidate'\n      }[stat.type] || stat.type;\n    };\n    return new Promise(function(resolve) {\n      // shim getStats with maplike support\n      var results = new Map();\n      Promise.all(promises).then(function(res) {\n        res.forEach(function(result) {\n          Object.keys(result).forEach(function(id) {\n            result[id].type = fixStatsType(result[id]);\n            results.set(id, result[id]);\n          });\n        });\n        if (cb) {\n          window.setTimeout(cb, 0, results);\n        }\n        resolve(results);\n      });\n    });\n  };\n  return RTCPeerConnection;\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/edge/rtcpeerconnection_shim.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!******************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\n\nvar firefoxShim = {\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n            this.removeEventListener('addstream', this._ontrackpoly);\n          }\n          this.addEventListener('track', this._ontrack = f);\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\n            e.stream.getTracks().forEach(function(track) {\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = {track: track};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            }.bind(this));\n          }.bind(this));\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function(window) {\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this.mozSrcObject;\n          },\n          set: function(stream) {\n            this.mozSrcObject = stream;\n          }\n        });\n      }\n    }\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\n        window.mozRTCPeerConnection)) {\n      return; // probably media.peerconnection.enabled=false in about:config\n    }\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (browserDetails.version < 38) {\n          // .urls is not supported in FF < 38.\n          // create RTCIceServers with a single url.\n          if (pcConfig && pcConfig.iceServers) {\n            var newIceServers = [];\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\n              var server = pcConfig.iceServers[i];\n              if (server.hasOwnProperty('urls')) {\n                for (var j = 0; j < server.urls.length; j++) {\n                  var newServer = {\n                    url: server.urls[j]\n                  };\n                  if (server.urls[j].indexOf('turn') === 0) {\n                    newServer.username = server.username;\n                    newServer.credential = server.credential;\n                  }\n                  newIceServers.push(newServer);\n                }\n              } else {\n                newIceServers.push(pcConfig.iceServers[i]);\n              }\n            }\n            pcConfig.iceServers = newIceServers;\n          }\n        }\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.mozRTCPeerConnection.prototype;\n\n      // wrap static methods. Currently just generateCertificate.\n      if (window.mozRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.mozRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\n    }\n\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n\n    // shim getStats with maplike support\n    var makeMapStats = function(stats) {\n      var map = new Map();\n      Object.keys(stats).forEach(function(key) {\n        map.set(key, stats[key]);\n        map[key] = stats[key];\n      });\n      return map;\n    };\n\n    var modernStatsTypes = {\n      inboundrtp: 'inbound-rtp',\n      outboundrtp: 'outbound-rtp',\n      candidatepair: 'candidate-pair',\n      localcandidate: 'local-candidate',\n      remotecandidate: 'remote-candidate'\n    };\n\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(\n      selector,\n      onSucc,\n      onErr\n    ) {\n      return nativeGetStats.apply(this, [selector || null])\n        .then(function(stats) {\n          if (browserDetails.version < 48) {\n            stats = makeMapStats(stats);\n          }\n          if (browserDetails.version < 53 && !onSucc) {\n            // Shim only promise getStats with spec-hyphens in type names\n            // Leave callback version alone; misc old uses of forEach before Map\n            try {\n              stats.forEach(function(stat) {\n                stat.type = modernStatsTypes[stat.type] || stat.type;\n              });\n            } catch (e) {\n              if (e.name !== 'TypeError') {\n                throw e;\n              }\n              // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n              stats.forEach(function(stat, i) {\n                stats.set(i, Object.assign({}, stat, {\n                  type: modernStatsTypes[stat.type] || stat.type\n                }));\n              });\n            }\n          }\n          return stats;\n        })\n        .then(onSucc, onErr);\n    };\n  }\n};\n\n// Expose public methods.\nmodule.exports = {\n  shimOnTrack: firefoxShim.shimOnTrack,\n  shimSourceObject: firefoxShim.shimSourceObject,\n  shimPeerConnection: firefoxShim.shimPeerConnection,\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\")\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!******************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n  var MediaStreamTrack = window && window.MediaStreamTrack;\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        InternalError: 'NotReadableError',\n        NotSupportedError: 'TypeError',\n        PermissionDeniedError: 'NotAllowedError',\n        SecurityError: 'NotAllowedError'\n      }[e.name] || e.name,\n      message: {\n        'The operation is insecure.': 'The request is not allowed by the ' +\n        'user agent or the platform in the current context.'\n      }[e.message] || e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  // getUserMedia constraints shim.\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    var constraintsToFF37_ = function(c) {\n      if (typeof c !== 'object' || c.require) {\n        return c;\n      }\n      var require = [];\n      Object.keys(c).forEach(function(key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = c[key] = (typeof c[key] === 'object') ?\n            c[key] : {ideal: c[key]};\n        if (r.min !== undefined ||\n            r.max !== undefined || r.exact !== undefined) {\n          require.push(key);\n        }\n        if (r.exact !== undefined) {\n          if (typeof r.exact === 'number') {\n            r. min = r.max = r.exact;\n          } else {\n            c[key] = r.exact;\n          }\n          delete r.exact;\n        }\n        if (r.ideal !== undefined) {\n          c.advanced = c.advanced || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[key] = {min: r.ideal, max: r.ideal};\n          } else {\n            oc[key] = r.ideal;\n          }\n          c.advanced.push(oc);\n          delete r.ideal;\n          if (!Object.keys(r).length) {\n            delete c[key];\n          }\n        }\n      });\n      if (require.length) {\n        c.require = require;\n      }\n      return c;\n    };\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (browserDetails.version < 38) {\n      logging('spec: ' + JSON.stringify(constraints));\n      if (constraints.audio) {\n        constraints.audio = constraintsToFF37_(constraints.audio);\n      }\n      if (constraints.video) {\n        constraints.video = constraintsToFF37_(constraints.video);\n      }\n      logging('ff37: ' + JSON.stringify(constraints));\n    }\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\n      onError(shimError_(e));\n    });\n  };\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      getUserMedia_(constraints, resolve, reject);\n    });\n  };\n\n  // Shim for mediaDevices on older versions.\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\n      addEventListener: function() { },\n      removeEventListener: function() { }\n    };\n  }\n  navigator.mediaDevices.enumerateDevices =\n      navigator.mediaDevices.enumerateDevices || function() {\n        return new Promise(function(resolve) {\n          var infos = [\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\n          ];\n          resolve(infos);\n        });\n      };\n\n  if (browserDetails.version < 41) {\n    // Work around http://bugzil.la/1169665\n    var orgEnumerateDevices =\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n    navigator.mediaDevices.enumerateDevices = function() {\n      return orgEnumerateDevices().then(undefined, function(e) {\n        if (e.name === 'NotFoundError') {\n          return [];\n        }\n        throw e;\n      });\n    };\n  }\n  if (browserDetails.version < 49) {\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      return origGetUserMedia(c).then(function(stream) {\n        // Work around https://bugzil.la/802326\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(function(track) {\n            track.stop();\n          });\n          throw new DOMException('The object can not be found here.',\n                                 'NotFoundError');\n        }\n        return stream;\n      }, function(e) {\n        return Promise.reject(shimError_(e));\n      });\n    };\n  }\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    var remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        var obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    if (browserDetails.version < 44) {\n      return getUserMedia_(constraints, onSuccess, onError);\n    }\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!****************************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\nvar utils = __webpack_require__(/*! ../utils */ \"./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js\");\n\nvar safariShim = {\n  // TODO: DrAlex, should be here, double check against LayoutTests\n\n  // TODO: once the back-end for the mac port is done, add.\n  // TODO: check for webkitGTK+\n  // shimPeerConnection: function() { },\n\n  shimLocalStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n    }\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\n        var result = null;\n        if (this._localStreams) {\n          this._localStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        if (this._remoteStreams) {\n          this._remoteStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        return result;\n      };\n    }\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        if (this._localStreams.indexOf(stream) === -1) {\n          this._localStreams.push(stream);\n        }\n        var self = this;\n        stream.getTracks().forEach(function(track) {\n          _addTrack.call(self, track, stream);\n        });\n      };\n\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n        if (stream) {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (this._localStreams.indexOf(stream) === -1) {\n            this._localStreams.push(stream);\n          }\n        }\n        _addTrack.call(this, track, stream);\n      };\n    }\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        var index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        var self = this;\n        var tracks = stream.getTracks();\n        this.getSenders().forEach(function(sender) {\n          if (tracks.indexOf(sender.track) !== -1) {\n            self.removeTrack(sender);\n          }\n        });\n      };\n    }\n  },\n  shimRemoteStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n    }\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n        get: function() {\n          return this._onaddstream;\n        },\n        set: function(f) {\n          if (this._onaddstream) {\n            this.removeEventListener('addstream', this._onaddstream);\n            this.removeEventListener('track', this._onaddstreampoly);\n          }\n          this.addEventListener('addstream', this._onaddstream = f);\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            var stream = e.streams[0];\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            var event = new Event('addstream');\n            event.stream = e.streams[0];\n            this.dispatchEvent(event);\n          }.bind(this));\n        }\n      });\n    }\n  },\n  shimCallbacksAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    var prototype = window.RTCPeerConnection.prototype;\n    var createOffer = prototype.createOffer;\n    var createAnswer = prototype.createAnswer;\n    var setLocalDescription = prototype.setLocalDescription;\n    var setRemoteDescription = prototype.setRemoteDescription;\n    var addIceCandidate = prototype.addIceCandidate;\n\n    prototype.createOffer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    prototype.createAnswer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    var withCallback = function(description, successCallback, failureCallback) {\n      var promise = setLocalDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n\n    withCallback = function(description, successCallback, failureCallback) {\n      var promise = setRemoteDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n\n    withCallback = function(candidate, successCallback, failureCallback) {\n      var promise = addIceCandidate.apply(this, [candidate]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n  },\n  shimGetUserMedia: function(window) {\n    var navigator = window && window.navigator;\n\n    if (!navigator.getUserMedia) {\n      if (navigator.webkitGetUserMedia) {\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n      } else if (navigator.mediaDevices &&\n          navigator.mediaDevices.getUserMedia) {\n        navigator.getUserMedia = function(constraints, cb, errcb) {\n          navigator.mediaDevices.getUserMedia(constraints)\n          .then(cb, errcb);\n        }.bind(navigator);\n      }\n    }\n  },\n  shimRTCIceServerUrls: function(window) {\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    var OrigPeerConnection = window.RTCPeerConnection;\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        var newIceServers = [];\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\n          var server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get: function() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n};\n\n// Expose public methods.\nmodule.exports = {\n  shimCallbacksAPI: safariShim.shimCallbacksAPI,\n  shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,\n  shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,\n  shimGetUserMedia: safariShim.shimGetUserMedia,\n  shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls\n  // TODO\n  // shimPeerConnection: safariShim.shimPeerConnection\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/safari/safari_shim.js?");

/***/ }),

/***/ "./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js":
/*!***************************************************************************!*\
  !*** ./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\n\n// Utility methods.\nvar utils = {\n  disableLog: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return (bool) ? 'adapter.js logging disabled' :\n        'adapter.js logging enabled';\n  },\n\n  /**\n   * Disable or enable deprecation warnings\n   * @param {!boolean} bool set to true to disable warnings.\n   */\n  disableWarnings: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n  },\n\n  log: function() {\n    if (typeof window === 'object') {\n      if (logDisabled_) {\n        return;\n      }\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  },\n\n  /**\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\n   */\n  deprecated: function(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n      return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n        ' instead.');\n  },\n\n  /**\n   * Extract browser version out of the provided user agent string.\n   *\n   * @param {!string} uastring userAgent string.\n   * @param {!string} expr Regular expression used as match criteria.\n   * @param {!number} pos position in the version string to be returned.\n   * @return {!number} browser version.\n   */\n  extractVersion: function(uastring, expr, pos) {\n    var match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n  },\n\n  /**\n   * Browser detector.\n   *\n   * @return {object} result containing browser and version\n   *     properties.\n   */\n  detectBrowser: function(window) {\n    var navigator = window && window.navigator;\n\n    // Returned result object.\n    var result = {};\n    result.browser = null;\n    result.version = null;\n\n    // Fail early if it's not a browser\n    if (typeof window === 'undefined' || !window.navigator) {\n      result.browser = 'Not a browser.';\n      return result;\n    }\n\n    // Firefox.\n    if (navigator.mozGetUserMedia) {\n      result.browser = 'firefox';\n      result.version = this.extractVersion(navigator.userAgent,\n          /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator.webkitGetUserMedia) {\n      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\n      if (window.webkitRTCPeerConnection) {\n        result.browser = 'chrome';\n        result.version = this.extractVersion(navigator.userAgent,\n          /Chrom(e|ium)\\/(\\d+)\\./, 2);\n      } else { // Safari (in an unpublished version) or unknown webkit-based.\n        if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\n          result.browser = 'safari';\n          result.version = this.extractVersion(navigator.userAgent,\n            /AppleWebKit\\/(\\d+)\\./, 1);\n        } else { // unknown webkit-based browser.\n          result.browser = 'Unsupported webkit-based browser ' +\n              'with GUM support but no WebRTC support.';\n          return result;\n        }\n      }\n    } else if (navigator.mediaDevices &&\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n      result.browser = 'edge';\n      result.version = this.extractVersion(navigator.userAgent,\n          /Edge\\/(\\d+).(\\d+)$/, 2);\n    } else if (navigator.mediaDevices &&\n        navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari, with webkitGetUserMedia removed.\n      result.browser = 'safari';\n      result.version = this.extractVersion(navigator.userAgent,\n          /AppleWebKit\\/(\\d+)\\./, 1);\n    } else { // Default fallthrough: not supported.\n      result.browser = 'Not a supported browser.';\n      return result;\n    }\n\n    return result;\n  },\n\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\n\n  shimCreateObjectURL: function(window) {\n    var URL = window && window.URL;\n\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\n          'srcObject' in window.HTMLMediaElement.prototype)) {\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\n      return undefined;\n    }\n\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\n    var streams = new Map(), newId = 0;\n\n    URL.createObjectURL = function(stream) {\n      if ('getTracks' in stream) {\n        var url = 'polyblob:' + (++newId);\n        streams.set(url, stream);\n        utils.deprecated('URL.createObjectURL(stream)',\n            'elem.srcObject = stream');\n        return url;\n      }\n      return nativeCreateObjectURL(stream);\n    };\n    URL.revokeObjectURL = function(url) {\n      nativeRevokeObjectURL(url);\n      streams.delete(url);\n    };\n\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\n                                              'src');\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\n      get: function() {\n        return dsc.get.apply(this);\n      },\n      set: function(url) {\n        this.srcObject = streams.get(url) || null;\n        return dsc.set.apply(this, [url]);\n      }\n    });\n\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\n    window.HTMLMediaElement.prototype.setAttribute = function() {\n      if (arguments.length === 2 &&\n          ('' + arguments[0]).toLowerCase() === 'src') {\n        this.srcObject = streams.get(arguments[1]) || null;\n      }\n      return nativeSetAttribute.apply(this, arguments);\n    };\n  }\n};\n\n// Export.\nmodule.exports = {\n  log: utils.log,\n  deprecated: utils.deprecated,\n  disableLog: utils.disableLog,\n  disableWarnings: utils.disableWarnings,\n  extractVersion: utils.extractVersion,\n  shimCreateObjectURL: utils.shimCreateObjectURL,\n  detectBrowser: utils.detectBrowser.bind(utils)\n};\n\n\n//# sourceURL=webpack:///./src/hyperty/connector/node_modules/webrtc-adapter/src/js/utils.js?");

/***/ })

/******/ })
			);
		}
	};
});